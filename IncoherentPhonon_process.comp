/*******************************************************************************
*
*  McStas, neutron ray-tracing package
*  Copyright(C) 2007 Risoe National Laboratory.
*
* %I
* Written by: Victor Laliena
* Date: 06.09.2017
* Origin: 
*
* A component to simulate inelastic scattering in the incoherent approximation
* Takes into account one, two, and three phonon scattering explicitly,
* and multi-phonon scattering (with n>4) via the saddle point method
* %D
*
*
* Part of the Union components, a set of components that work together and thus
* expects geometry and physics within McStas.
* The use of this component requires other components to be used.
*
* 1) One specifies a number of processes using process components like this one
* 2) These are gathered into material definitions using Union_make_material
* 3) Geometries are placed using Union_box / Union_cylinder, assigned a material
* 4) A Union_master component placed after all of the above
*
*
* Algorithm:
* Described elsewhere
*
* %P
* INPUT PARAMETERS:
* T [K]             Temperature
* density [g/cm3]   Material density
* M [amu]           ion mass
* sigmaCoh [barns]  Coherent scattering cross section
* sigmaInc [barns]  Incoherent scattering cross section
* dosfn [string]    Path to the file that contains the DoS
* nxs [1]           Number of energy points at which the total cross sections are precomputed
* kabsmin [A^-1]    Lower cut-off for the neutron wave-vector k
* kabsmin [A^-1]    Higher cut-off for the neutron wave-vector k 
* Interact_fraction [1]   How large a part of the scattering events should use this process 0-1 (sum of all processes in material = 1)
*
* OUTPUT PARAMETERS:
*
* This_process
* IncoherentPhonon_storage
*
* %L
* The test/example instrument <a href="../examples/Test_IncoherentPhonon.instr">Test_IncoherentPhonon.instr</a>.
*
* %E
******************************************************************************/

DEFINE COMPONENT IncoherentPhonon_process
DEFINITION PARAMETERS ()
//default parameters for aluminium
//SETTING PARAMETERS(T=295,density=2.7,M=26.98,sigmaCoh=1.495,sigmaInc=0.0082,char *dosfn=NULL,nxs=1000,kabsmin=0.1,kabsmax=25,interact_fraction=-1)
// default parameters for vanadium
SETTING PARAMETERS(T=294,density=6.0,M=50.94,sigmaCoh=0.0184,sigmaInc=5.08,char *dosfn=NULL,nxs=1000,kabsmin=0.1,kabsmax=25,interact_fraction=-1)
OUTPUT PARAMETERS (This_process,IncoherentPhonon_storage)

/* Neutron parameters: (x,y,z,vx,vy,vz,t,sx,sy,sz,p) */

SHARE
%{
#ifndef Union
#define Union $Revision: 0.8 $

#include "Union_functions.c"
#include "Union_initialization.c"

#endif

#ifndef INCOHERENTPHONON
#define INCOHERENTPHONON
#define maxIter    1000            // Maximum number of iterations for sampling via the rejection method
#define KS2E       2.0721          // Energy / wave-vector^2 constant
#define kB         8.6173342e-2    // Boltzmann constant in meV/K 
#define amu        1.66053892e-27  // atomic mass unit in kg
#define barn2cmsq  1.0e-24         // conversion factor from barn to cm2
#define nFCmax     10000000        // maximum number of function calls in nunerical integration
#endif

struct IncoherentPhonon_physics_storage_struct{
// Variables that needs to be transfered between any of the following places:
// The initialize in this component
// The function for calculating my
// The function for calculating scattering

  //Physical parameters
  double T;           // Temperature [K] 
  double density;     // Material density [g/cm3] 
  double M;           // Ion mass [amu]
  double sigmaCoh;    // Coherent cross section [barn] 
  double sigmaInc;    // Incoherent cross section [barn] 
  double kBT;         // Boltzmann constant times temperature [meV]
  double mRat;        // ratio of neutron mass to ion mass (m/M)
  double XS2mu;       // conversion from cross section (barn) to linear attenuation coefficient (m^-1)

  //Inelastic cross section
  int    nxs;             // Number of kabs points at which the cross section is precomputed
  double kabsmin;         // Lower cut-off for neutron wave vector [1/A]
  double kabsmax;         // Higher cut-off for neutron wave vector [1/A]
  double *kabs;           // array of kabs points (of length nxs) at which the cross section is precomputed 

  //phonon expansion variables
  double *xsTot_1ph;      // array of precomputed one-phonon cross sections at the given kabs points (length nxs) 
  double *xsTot_2ph;      // array of precomputed two-phonon cross sections at the given kabs points (length nxs) 
  double *xsTot_3ph;      // array of precomputed three-phonon cross sections at the given kabs points (length nxs) 
  double *xsTot_mph;      // array of precomputed multi-phonon cross sections at the given kabs points (length nxs) 
  double *dXSdx_xmax_1ph;  // array with the energy transfer (x) at which the cross section is maximum, at the given kabs points (length nxs) 
  double *dXSdx_xmax_2ph;  // array with the energy transfer (x) at which the cross section is maximum, at the given kabs points (length nxs) 
  double *dXSdx_xmax_3ph;  // array with the energy transfer (x) at which the cross section is maximum, at the given kabs points (length nxs) 
  double *dXSdx_Fmax_1ph;   // array with the maximum cross sections at the given kabs points (length nxs) 
  double *dXSdx_Fmax_2ph;   // array with the maximum cross sections at the given kabs points (length nxs) 
  double *dXSdx_Fmax_3ph;   // array with the maximum cross sections at the given kabs points (length nxs) 

  int nF1;
  int nF2;
  int nF3;
  double *u1;
  double *u2;
  double *u3;
  double *F1;
  double *F2;
  double *F3;
  double tolQuadratureFs;

  // Multi-phonon variables
  double ximin;
  double ximax;
  int ntsp;
  double *xi;
  double *tsp;
  double *g;
  double *d2g;
  double *H;
  double g0;
  double d2g0;
  double xi1;
  double xi2;
  double aH3;
  double aH4;
  double tolSaddlePoint;
  double tolQuadratureGs;

  int    np_u_mph;
  double *u;
  double *dXSdu_mph;
  double tol_dXSdu_mph;

  double *dXSdQ2_Q2max_mph;
  double *dXSdQ2_Fmax_mph;
  double *Q2min;
  double *Q2max;

  //Density of States
  int    np;          // number of energy points at which the DoS is known
  double *e;          // array with the energy at which the DoS is known (length np)
  double *Z;          // array with the DoS at the energies at which it is known (length np)
  double Emax;        // cut-off energy for DoS (DoS vanishes above Emax)
  double dosPar;      // parabolic form of the DoS for E->0: DoS(E) = dosPar*E*E for E->0
  char   dosfn[250];  // Path to the DoS file

  //Log file
  FILE *filep;
};

// function declarations

void computeTotXS(struct IncoherentPhonon_physics_storage_struct *data);

// phonon expansion
double sampleKprime_1ph(double kabs, struct IncoherentPhonon_physics_storage_struct *data);
double sampleKprime_2ph(double kabs, struct IncoherentPhonon_physics_storage_struct *data);
double sampleKprime_3ph(double kabs, struct IncoherentPhonon_physics_storage_struct *data);
double sampleDir(double x, double E, int p, struct IncoherentPhonon_physics_storage_struct *data);

void compute_dXSdx_max_1ph(int n, double kabs, struct IncoherentPhonon_physics_storage_struct *data, double *xm, double *xsDiffMax);
void compute_dXSdx_max_2ph(int n, double kabs, struct IncoherentPhonon_physics_storage_struct *data, double *xm, double *xsDiffMax);
void compute_dXSdx_max_3ph(int n, double kabs, struct IncoherentPhonon_physics_storage_struct *data, double *xm, double *xsDiffMax);

double dXSdx_1ph(double x, double E, struct IncoherentPhonon_physics_storage_struct *data);
double dXSdx_2ph(double x, double E, struct IncoherentPhonon_physics_storage_struct *data);
double dXSdx_3ph(double x, double E, struct IncoherentPhonon_physics_storage_struct *data);

double dXSdz_pph(double kabs, double z, int p, struct IncoherentPhonon_physics_storage_struct *data);

double angularIntegral_p_phonon(int p, double alpha, double x);

double totXS_1ph(double kabs, struct IncoherentPhonon_physics_storage_struct *data);
double totXS_2ph(double kabs, struct IncoherentPhonon_physics_storage_struct *data);
double totXS_3ph(double kabs, struct IncoherentPhonon_physics_storage_struct *data);

void computeFs(struct IncoherentPhonon_physics_storage_struct *data);

double F1(double u, struct IncoherentPhonon_physics_storage_struct *data);
double F2(double u, struct IncoherentPhonon_physics_storage_struct *data);
double F3(double u, struct IncoherentPhonon_physics_storage_struct *data);

double F2int(double u, double u1, struct IncoherentPhonon_physics_storage_struct *data);
double F3int(double u, double u1, double u2, struct IncoherentPhonon_physics_storage_struct *data);

double quadF2(double u, struct IncoherentPhonon_physics_storage_struct *data);
double trapezF2(double u, int n, double umin, double umax, struct IncoherentPhonon_physics_storage_struct *data);
double quadF3(double u, struct IncoherentPhonon_physics_storage_struct *data);
double trapezF3(double u, int n, double umin, double umax, struct IncoherentPhonon_physics_storage_struct *data);
double quadF3u2(double u, double u1, struct IncoherentPhonon_physics_storage_struct *data);
double trapezF3u2(double u, double u1, int n, double umin, double umax, struct IncoherentPhonon_physics_storage_struct *data);

// multi-phonon
void sample_Kprime_and_Dir_mph(double kabs, double *x, double *z, struct IncoherentPhonon_physics_storage_struct *data);
double sample_u_mph(double umax, struct IncoherentPhonon_physics_storage_struct *data);
double sample_Q2_mph(double u, double Erat, struct IncoherentPhonon_physics_storage_struct *data);

double totXS_mph(double kabs, struct IncoherentPhonon_physics_storage_struct *data);

void compute_dXSdu_mph(struct IncoherentPhonon_physics_storage_struct *data);
double quad_dXSdu_mph(double u, struct IncoherentPhonon_physics_storage_struct *data);
double trapez_dXSdu_mph(double u, int n, double Q2max, struct IncoherentPhonon_physics_storage_struct *data);

void compute_dXSdQ2_max_mph(struct IncoherentPhonon_physics_storage_struct *data);

double dXSdxdz_mph(double kabs, double x, double z, struct IncoherentPhonon_physics_storage_struct *data);
double dXSdx_mph(double kabs, double x, struct IncoherentPhonon_physics_storage_struct *data);
double dXSdz_mph(double kabs, double z, struct IncoherentPhonon_physics_storage_struct *data);

double SFunc(double Q2, double xi, struct IncoherentPhonon_physics_storage_struct *data);
double SFuncInterp(double Q2, double xi, struct IncoherentPhonon_physics_storage_struct *data);

void computeSaddlePointSol(int ntsp, double ximin, double ximax, struct IncoherentPhonon_physics_storage_struct *data);
void tspInterp(double xi, double *tsp, double *g, double *d2g, double *H, struct IncoherentPhonon_physics_storage_struct *data);
double saddlePoint(double xi, struct IncoherentPhonon_physics_storage_struct *data);

double Gt(double ti, struct IncoherentPhonon_physics_storage_struct *data);
double dGt(double ti, struct IncoherentPhonon_physics_storage_struct *data);
double d2Gt(double ti, struct IncoherentPhonon_physics_storage_struct *data);
double Gtint(double u, double ti, struct IncoherentPhonon_physics_storage_struct *data);
double dGtint(double u, double ti, struct IncoherentPhonon_physics_storage_struct *data);
double d2Gtint(double u, double ti, struct IncoherentPhonon_physics_storage_struct *data);

double quad_mp(double ti, struct IncoherentPhonon_physics_storage_struct *data, double (*func)(double,double,struct IncoherentPhonon_physics_storage_struct *));
double trapez_mp(int n, double umin, double umax, double ti, struct IncoherentPhonon_physics_storage_struct *data,
		 double (*func)(double,double,struct IncoherentPhonon_physics_storage_struct *));

// general functions
double Gu(double u, struct IncoherentPhonon_physics_storage_struct *data);
double bose(double x);
double interpFunc(double u, int n, double *up, double *Fp);


// input/output etc.
void readDoS(struct IncoherentPhonon_physics_storage_struct *data);
double dos(double E, struct IncoherentPhonon_physics_storage_struct *data);

void setParams(struct IncoherentPhonon_physics_storage_struct *data, 
               double T, double density, double M, double sigmaCoh, 
               double sigmaInc, double kabsmin, double kabsmax, 
	       int nxs, char *dosfn, int ntsp, double ximin, double ximax, char *filelog);

int finish(struct IncoherentPhonon_physics_storage_struct *data);

// end function declaration

/*******************************************************************/

// Function for calculating my in Incoherent phonon case
int IncoherentPhonon_physics_my(double *my,double *k_initial, union data_transfer_union data_transfer, struct focus_data_struct *focus_data) {
    struct IncoherentPhonon_physics_storage_struct *data = data_transfer.pointer_to_a_IncoherentPhonon_physics_storage_struct;
    double kabs = sqrt(k_initial[0]*k_initial[0] +  k_initial[1]*k_initial[1] + k_initial[2]*k_initial[2]);
    double xs1ph = interpFunc(kabs,data->nxs,data->kabs,data->xsTot_1ph);
    double xs2ph = interpFunc(kabs,data->nxs,data->kabs,data->xsTot_2ph);
    double xs3ph = interpFunc(kabs,data->nxs,data->kabs,data->xsTot_3ph);
    double xsmph = interpFunc(kabs,data->nxs,data->kabs,data->xsTot_mph);
    *my = (data->XS2mu)*(xs1ph + xs2ph + xs3ph +xsmph);
    return 1;
};

// Function for incoherent phonon scattering event
int IncoherentPhonon_physics_scattering(double *k_final, double *k_initial, double *weight, union data_transfer_union data_transfer, struct focus_data_struct *focus_data) {
    int type;
    double kabs, E, xs1ph, xs2ph, xs3ph, xsmph, xstot;  
    double x, ct, st, phi, cp, sp;
    double ki[3], t1[3], t2[3], kprime[3];
    double rnd;
    struct IncoherentPhonon_physics_storage_struct *data = data_transfer.pointer_to_a_IncoherentPhonon_physics_storage_struct;

    ki[0] = k_initial[0];
    ki[1] = k_initial[1];
    ki[2] = k_initial[2];
  
    kabs = sqrt(ki[0]*ki[0]+ki[1]*ki[1]+ki[2]*ki[2]);
    E = KS2E*kabs*kabs;

    // there should be an extrapolation of tthe cross section fron kabs=kabsmin dow to kabs=0 and from kabs=kabsmax to infinity
    //if(kabs<data->kabsmin || kabs>data->kabsmax) { ABSORB; return -1; }

    // sample scattering type
    xs1ph = interpFunc(kabs,data->nxs,data->kabs,data->xsTot_1ph);
    xs2ph = interpFunc(kabs,data->nxs,data->kabs,data->xsTot_2ph);
    xs3ph = interpFunc(kabs,data->nxs,data->kabs,data->xsTot_3ph);
    xsmph = interpFunc(kabs,data->nxs,data->kabs,data->xsTot_mph);
    xstot = xs1ph + xs2ph + xs3ph +xsmph;

    rnd = rand01();
    if(rnd<xs1ph/xstot) {
      //one-phonon
      //Sample energy
      type = 1;
      x = sampleKprime_1ph(kabs,data);
      if(x<0) { 
      	fprintf(data->filep,
	  "sampleKprime_1ph returns negative: %f It seems maxIter=%d exceeded. Exiting\n",x,maxIter);
        exit(1);
      }
      // Sample polar direction
      ct = sampleDir(x,E,1,data);
      if(ct<-1) { 
        fprintf(data->filep,"sampleDir 1ph returns < -1: %f It seems maxIter exceeded. Exiting\n",ct);
        exit(1);
      }
    } else if(rnd<(xs1ph+xs2ph)/xstot) {
      //two-phonon
      //Sample energy
      type = 2;
      x = sampleKprime_2ph(kabs,data);
      if(x<0) { 
        fprintf(data->filep,
	    "sampleKprime_2ph returns negative: %f It seems maxIter=%d exceeded. Exiting\n",x,maxIter);
        exit(1);
      }
      // Sample polar direction
      ct = sampleDir(x,E,2,data);
      if(ct<-1) { 
        fprintf(data->filep,"sampleDir 2ph returns < -1: %f It seems maxIter exceeded. Exiting\n",ct);
        exit(1);
      }
    } else if(rnd<(xs1ph+xs2ph+xs3ph)/xstot) {
      //three-phonon
      //Sample energy
      type = 3;
      x = sampleKprime_3ph(kabs,data);
      if(x<0) { 
        fprintf(data->filep,
	   "sampleKprime_3ph returns negative: %f It seems maxIter=%d exceeded. Exiting\n",x,maxIter);
        exit(1);
      }
      // Sample polar direction
      ct = sampleDir(x,E,3,data);
      if(ct<-1) { 
        fprintf(data->filep,"sampleDir 3ph returns < -1: %f It seems maxIter exceeded. Exiting\n",ct);
        exit(1);
      }
    } else {
      type = 0;
      //multi-phonon
      //Sample energy and polar direction
      sample_Kprime_and_Dir_mph(kabs,&x,&ct,data);
    }

    st = sqrt(1.-ct*ct);
  
    // sample azimuthal direction
    phi = 2.*PI*rand01();
    cp = cos(phi);
    sp = sin(phi);

    // build kprime (ki,t1,t2) orthonormal right handed triad
    NORM(ki[0],ki[1],ki[2]);
    normal_vec(t1[0],t1[1],t1[2],ki[0],ki[1],ki[2]);
    vec_prod(t2[0],t2[1],t2[2],ki[0],ki[1],ki[2],t1[0],t1[1],t1[2]);

    kprime[0] = ct*ki[0] + st*(cp*t1[0] + sp*t2[0]);
    kprime[1] = ct*ki[1] + st*(cp*t1[1] + sp*t2[1]);
    kprime[2] = ct*ki[2] + st*(cp*t1[2] + sp*t2[2]);

    // x = kprime/k, with normalized kprime
    kabs = x*kabs/sqrt(kprime[0]*kprime[0]+kprime[1]*kprime[1]+kprime[2]*kprime[2]);  

    k_final[0] = kabs*kprime[0]; 
    k_final[1] = kabs*kprime[1];
    k_final[2] = kabs*kprime[2];

    *weight = 1.0;

    return type;
};

// Start implementation of internal functions

void computeTotXS(struct IncoherentPhonon_physics_storage_struct *data)
{
  int i;
  double dkabs;
  double xi, dxi;
  FILE *filep;

  data->kabs = (double *)malloc((data->nxs)*sizeof(double));
  data->xsTot_1ph = (double *)malloc((data->nxs)*sizeof(double));
  data->xsTot_2ph = (double *)malloc((data->nxs)*sizeof(double));
  data->xsTot_3ph = (double *)malloc((data->nxs)*sizeof(double));
  data->xsTot_mph = (double *)malloc((data->nxs)*sizeof(double));

  data->dXSdx_xmax_1ph = (double *)malloc((data->nxs)*sizeof(double));
  data->dXSdx_xmax_2ph = (double *)malloc((data->nxs)*sizeof(double));
  data->dXSdx_xmax_3ph = (double *)malloc((data->nxs)*sizeof(double));

  data->dXSdx_Fmax_1ph = (double *)malloc((data->nxs)*sizeof(double));
  data->dXSdx_Fmax_2ph = (double *)malloc((data->nxs)*sizeof(double));
  data->dXSdx_Fmax_3ph = (double *)malloc((data->nxs)*sizeof(double));

  computeFs(data);
  computeSaddlePointSol(data->ntsp,data->ximin,data->ximax,data);

  compute_dXSdu_mph(data);
  compute_dXSdQ2_max_mph(data);

  dkabs = (data->kabsmax-data->kabsmin)/(data->nxs);

  (data->kabs)[0] = data->kabsmin;
  for(i=1;i<data->nxs;i++) {
    (data->kabs)[i] = (data->kabs)[i-1] + dkabs;
  }

  filep = fopen("XS.txt","w");
  for(i=0;i<data->nxs;i++) {
    printf("XStot: %d %f %f\n",i,(data->kabs)[i],KS2E*pow((data->kabs)[i],2));
    (data->xsTot_1ph)[i] = totXS_1ph((data->kabs)[i],data);
    (data->xsTot_2ph)[i] = totXS_2ph((data->kabs)[i],data);
    (data->xsTot_3ph)[i] = totXS_3ph((data->kabs)[i],data);
    (data->xsTot_mph)[i] = totXS_mph((data->kabs)[i],data);
    fprintf(filep,"%f %.6e %.6e %.6e %.6e\n",KS2E*pow((data->kabs)[i],2),
	    (data->xsTot_1ph)[i],(data->xsTot_2ph)[i],(data->xsTot_3ph)[i],(data->xsTot_mph)[i]);
    fflush(filep);
  }
  fclose(filep);

  filep = fopen("dXSdx_max.txt","w");
  for(i=0;i<data->nxs;i++) {
    printf("Max: %d %f %f\n",i,(data->kabs)[i],KS2E*pow((data->kabs)[i],2));
    compute_dXSdx_max_1ph(1000,(data->kabs)[i],data,(data->dXSdx_xmax_1ph)+i,(data->dXSdx_Fmax_1ph)+i);
    compute_dXSdx_max_2ph(1000,(data->kabs)[i],data,(data->dXSdx_xmax_2ph)+i,(data->dXSdx_Fmax_2ph)+i);
    compute_dXSdx_max_3ph(1000,(data->kabs)[i],data,(data->dXSdx_xmax_3ph)+i,(data->dXSdx_Fmax_3ph)+i);
    fprintf(filep,"%f %.6e %.6e %.6e %.6e %.6e %.6e\n",
	    KS2E*pow((data->kabs)[i],2),
	    (data->dXSdx_xmax_1ph)[i], (data->dXSdx_Fmax_1ph)[i],
	    (data->dXSdx_xmax_2ph)[i], (data->dXSdx_Fmax_2ph)[i],
	    (data->dXSdx_xmax_3ph)[i], (data->dXSdx_Fmax_3ph)[i]);
    fflush(filep);
  }
  fclose(filep);
};

///////////////////////////
// Phonon expansion    ////
///////////////////////////

double sampleKprime_1ph(double kabs, struct IncoherentPhonon_physics_storage_struct *data)
{
  //x = kprime/k
  int i;
  double E = KS2E*kabs*kabs;
  double pxmax = interpFunc(kabs,data->nxs,data->kabs,data->dXSdx_Fmax_1ph);
  double xmax = sqrt(1.+(data->Emax)/E);
  double x, px;
  FILE *filep;
  for(i=0;i<maxIter;i++) {
    x =  xmax*rand01();
    px = dXSdx_1ph(x,E,data);
    if(px>pxmax) {
      printf("sampleKprime_1ph:\n");
      printf("x: %.6e\n",x);
      printf("xmax: %.6e\n",xmax);
      printf("pxmax: %.6e\n",pxmax);
      printf("px: %.6e\n",px);
      printf("px/pxmax: %.6e\n",px/pxmax);
      filep = fopen("dXSdx_1ph.txt","w");
      x = 0;
      while(x<=xmax) {
	px = dXSdx_1ph(x,E,data);
	fprintf(filep,"%f %.16e %.16e\n",x,px,pxmax);
	x += xmax/1000;
      }
      fclose(filep);
      exit(1);
    }
    if(px/pxmax>rand01()) { return x; }
  }
  //What happens if maxIter is exceeded?? return negative value to control
  printf("sampleKprime_1ph: maxIter exceeded\n");
  filep = fopen("dXSdx_1ph_maxIter_exceeded.txt","w");
  x = 0;
  while(x<=xmax) {
    px = dXSdx_1ph(x,E,data);
    fprintf(filep,"%f %.16e %.16e\n",x,px,pxmax);
    x += xmax/1000;
  }
  fclose(filep);
  return -1;
};

double sampleKprime_2ph(double kabs, struct IncoherentPhonon_physics_storage_struct *data)
{
  //x = kprime/k
  int i;
  double E = KS2E*kabs*kabs;
  double pxmax = interpFunc(kabs,data->nxs,data->kabs,data->dXSdx_Fmax_2ph);
  double xmax = sqrt(1.+2.0*(data->Emax)/E);
  double x, px;
  FILE *filep;
  for(i=0;i<maxIter;i++) {
    x =  xmax*rand01();
    px = dXSdx_2ph(x,E,data);
    if(px>pxmax) {
      printf("sampleKprime_2ph:\n");
      printf("x: %.6e\n",x);
      printf("xmax: %.6e\n",xmax);
      printf("pxmax: %.6e\n",pxmax);
      printf("px: %.6e\n",px);
      printf("px/pxmax: %.6e\n",px/pxmax);
      filep = fopen("dXSdx_2ph.txt","w");
      x = 0;
      while(x<=xmax) {
	px = dXSdx_2ph(x,E,data);
	fprintf(filep,"%f %.16e %.16e\n",x,px,pxmax);
	x += xmax/1000;
      }
      fclose(filep);

      exit(1);
    }
    if(px/pxmax>rand01()) { return x; }
  }
  //What happens if maxIter is exceeded?? return negative value to control
  filep = fopen("dXSdx_2ph_maxIter_exceeded.txt","w");
  x = 0;
  while(x<=xmax) {
    px = dXSdx_2ph(x,E,data);
    fprintf(filep,"%f %.16e %.16e\n",x,px,pxmax);
    x += xmax/1000;
  }
  fclose(filep);
  return -1;
};

double sampleKprime_3ph(double kabs, struct IncoherentPhonon_physics_storage_struct *data)
{
  //x = kprime/k
  int i;
  double E = KS2E*kabs*kabs;
  double pxmax = interpFunc(kabs,data->nxs,data->kabs,data->dXSdx_Fmax_3ph);
  double xmax = sqrt(1.+3.0*(data->Emax)/E);
  double x, px;
  FILE *filep;
  for(i=0;i<maxIter;i++) {
    x =  xmax*rand01();
    px = dXSdx_3ph(x,E,data);
    if(px>pxmax) {
      printf("sampleKprime_3ph:\n");
      printf("px: %.6e\n",px);
      printf("xmax: %.6e\n",xmax);
      printf("pxmax: %.6e\n",pxmax);
      printf("px: %.6e\n",px);
      printf("px/pxmax: %.6e\n",px/pxmax);
      filep = fopen("dXSdx_3ph.txt","w");
      x = 0;
      while(x<=xmax) {
	px = dXSdx_3ph(x,E,data);
	fprintf(filep,"%f %.16e %.16e\n",x,px,pxmax);
	x += xmax/1000;
      }
      fclose(filep);
      exit(1);
    }
    if(px/pxmax>rand01()) { return x; }
  }
  //What happens if maxIter is exceeded?? return negative value to control
  filep = fopen("dXSdx_3ph_maxIter_exceeded.txt","w");
  x = 0;
  while(x<=xmax) {
    px = dXSdx_3ph(x,E,data);
    fprintf(filep,"%f %.16e %.16e\n",x,px,pxmax);
    x += xmax/1000;
  }
  fclose(filep);
  return -1;
};

double sampleDir(double x, double E, int p, struct IncoherentPhonon_physics_storage_struct *data)
{
  // return z=cos(theta)
  if(x<=0) { return 1; }
  int i;
  double z, Q2, pz, pzmax;
  double g0 = data->g0;
  double fac = (E/(data->Emax))*(data->mRat);
  double Q2min = fac*pow(1-x,2);
  double Q2max = fac*pow(1+x,2);
  double Q2med = p/g0;
  double pz1 = exp(-g0*Q2min)*pow(Q2min,p);
  double pz2 = exp(-g0*Q2med)*pow(Q2med,p);
  double pz3 = exp(-g0*Q2max)*pow(Q2max,p);
  double dQ2 = Q2max - Q2min;

  //determine the maximum
  if(pz1>pz3) { pzmax = pz1; } else { pzmax = pz3; }
  if(Q2min<Q2med && Q2med<Q2max && pz2>pzmax) { pzmax = pz2; }
 
  for(i=0;i<maxIter;i++) {
    z = -1.0 + 2.0*rand01();
    Q2 = fac*(1 + x*x - 2.0*x*z);
    pz = exp(-g0*Q2)*pow(Q2,p);
    if(pz/pzmax>1) { 
      printf("sampleDir:\n");
      printf("Q2min: %f\n",Q2min);
      printf("Q2med: %f\n",Q2med);
      printf("Q2max: %f\n",Q2max);
      printf("Q2: %f\n",Q2);
      printf("pz1: %.6e\n",pz1);
      printf("pz2: %.6e\n",pz2);
      printf("pz3: %.6e\n",pz3);
      printf("pzmax: %.6e\n",pzmax);
      printf("pz: %.6e\n",pz);
      printf("pz/pzmax: %.6e\n",pz/pzmax);
      exit(1);
    }
    if(pz/pzmax>rand01()) { return z; }
  }

  //What happens if maxIter is exceeded?? return -1000 to control
  return -1000;
};

void compute_dXSdx_max_1ph(int n, double kabs, struct IncoherentPhonon_physics_storage_struct *data, double *xm, double *xsDiffMax)
{
  int i;
  double x, xmax, dx, ss;
  double E = KS2E*kabs*kabs;

  xmax = sqrt(1.+(data->Emax)/E);
  dx = xmax/n;

  x = 0;
  *xm = 0;
  *xsDiffMax = dXSdx_1ph(x,E,data);
  for(i=0;i<n;i++) {
    x += dx;
    ss = dXSdx_1ph(x,E,data);
    if(ss>(*xsDiffMax)) { *xsDiffMax = ss; *xm = x; }
  }
  ss = dXSdx_1ph(xmax,E,data);
  if(ss>(*xsDiffMax)) { *xsDiffMax = ss; *xm = xmax; }
  // refine
  if(*xm>0 && *xm<xmax) {
    xmax = *xm + dx;
    x = *xm - dx;
    dx /= 100;
    *xm = x;
    *xsDiffMax = dXSdx_1ph(x,E,data);
    for(i=0;i<200;i++) {
      x += dx;
      ss = dXSdx_1ph(x,E,data);
      if(ss>(*xsDiffMax)) { *xsDiffMax = ss; *xm = x; }
    }
  }
  // security
  *xsDiffMax *= 1.01; 
};

void compute_dXSdx_max_2ph(int n, double kabs, struct IncoherentPhonon_physics_storage_struct *data, double *xm, double *xsDiffMax)
{
  int i;
  double x, xmax, dx, ss;
  double E = KS2E*kabs*kabs;

  xmax = sqrt(1.+2.*(data->Emax)/E);
  dx = xmax/n;

  x = 0;
  *xm = 0;
  *xsDiffMax = dXSdx_2ph(x,E,data);
  for(i=0;i<n;i++) {
    x += dx;
    ss = dXSdx_2ph(x,E,data);
    if(ss>(*xsDiffMax)) { *xsDiffMax = ss; *xm = x; }
  }
  ss = dXSdx_2ph(xmax,E,data);
  if(ss>(*xsDiffMax)) { *xsDiffMax = ss; *xm = xmax; }
  // refine
  if(*xm>0 && *xm<xmax) {
    xmax = *xm + dx;
    x = *xm - dx;
    dx /= 100;
    *xm = x;
    *xsDiffMax = dXSdx_2ph(x,E,data);
    for(i=0;i<200;i++) {
      x += dx;
      ss = dXSdx_2ph(x,E,data);
      if(ss>(*xsDiffMax)) { *xsDiffMax = ss; *xm = x; }
    }
  }
  // security
  *xsDiffMax *= 1.01; 
};

void compute_dXSdx_max_3ph(int n, double kabs, struct IncoherentPhonon_physics_storage_struct *data, double *xm, double *xsDiffMax)
{
  int i;
  double x, xmax, dx, ss;
  double E = KS2E*kabs*kabs;

  xmax = sqrt(1.+3.*(data->Emax)/E);
  dx = xmax/n;

  x = 0;
  *xm = 0;
  *xsDiffMax = dXSdx_3ph(x,E,data);
  for(i=0;i<n;i++) {
    x += dx;
    ss = dXSdx_3ph(x,E,data);
    if(ss>(*xsDiffMax)) { *xsDiffMax = ss; *xm = x; }
  }
  ss = dXSdx_3ph(xmax,E,data);
  if(ss>(*xsDiffMax)) { *xsDiffMax = ss; *xm = xmax; }
  // refine
  if(*xm>0 && *xm<xmax) {
    xmax = *xm + dx;
    x = *xm - dx;
    dx /= 100;
    *xm = x;
    *xsDiffMax = dXSdx_3ph(x,E,data);
    for(i=0;i<200;i++) {
      x += dx;
      ss = dXSdx_3ph(x,E,data);
      if(ss>(*xsDiffMax)) { *xsDiffMax = ss; *xm = x; }
    }
  }
  // security
  *xsDiffMax *= 1.01; 
};

double dXSdx_1ph(double x, double E, struct IncoherentPhonon_physics_storage_struct *data)
{
  double Erat = E/(data->Emax);
  double u = Erat*(1.0-x*x);
  if(fabs(u)>1) { return 0; }
  double Fp = interpFunc(u,data->nF1,data->u1,data->F1);
  if(isnan(Fp)) {
    printf("dXSdx_1ph: F1 not interpolated\n");
    exit(1);
  }
  double alpha = Erat*(data->mRat)*(data->g0);
  double ang = angularIntegral_p_phonon(1,alpha,x);
  return x*Fp*ang;
};

double dXSdx_2ph(double x, double E, struct IncoherentPhonon_physics_storage_struct *data)
{
  double Erat = E/(data->Emax);
  double u = Erat*(1.0-x*x);
  if(fabs(u)>2) { return 0; }
  double Fp = interpFunc(u,data->nF2,data->u2,data->F2);
  if(isnan(Fp)) {
    printf("dXSdx_2ph: F2 not interpolated\n");
    exit(1);
  }
  double alpha = Erat*(data->mRat)*(data->g0);
  double ang = angularIntegral_p_phonon(2,alpha,x);
  return x*Fp*ang;
};

double dXSdx_3ph(double x, double E, struct IncoherentPhonon_physics_storage_struct *data)
{
  double Erat = E/(data->Emax);
  double u = Erat*(1.0-x*x);
  if(fabs(u)>3) { return 0; }
  double Fp = interpFunc(u,data->nF3,data->u3,data->F3);
  if(isnan(Fp)) {
    printf("dXSdx_3ph: F3 not interpolated\n");
    exit(1);
  }
  double alpha = Erat*(data->mRat)*(data->g0);
  double ang = angularIntegral_p_phonon(3,alpha,x);
  return x*Fp*ang;
};

// cross section as a function of z for the p-phonon term
double dXSdz_pph(double kabs, double z, int p, struct IncoherentPhonon_physics_storage_struct *data)
{
  // x = kprime/k
  // z = cos(theta)
  int i, nF, n = p*100000;
  double *up, *F;
  double x, xmax, dx, u, Fp, Q2, f, ss;
  double g0 = data->g0;
  double E = KS2E*kabs*kabs;
  double Erat = E/(data->Emax);
  double EMrat = (data->mRat)*Erat;

  if(fabs(z)>1) { return 0; }

  switch(p) {
  case 1:
    nF = data->nF1;
    up = data->u1;
    F = data->F1;
    break;
  case 2:
    nF = data->nF2;
    up = data->u2;
    F = data->F2;
    break;
  case 3:
    nF = data->nF3;
    up = data->u3;
    F = data->F3;
    break;
  default:
    printf("dXSdz_pph: invalid p: %d\n",p);
    exit(1);
  }

  xmax = sqrt(1.+p*(data->Emax)/E);
  dx = xmax/n;
  ss = 0;
  for(i=0;i<=n;i++) {
    x = i*dx;
    u = Erat*(1.0-x*x);
    Fp = interpFunc(u,nF,up,F);
    Q2 = EMrat*(1.0 + x*x - 2.0*x*z);
    f = x*x*Fp*exp(-g0*Q2)*pow(Q2,p);
    if(i==0 || i==n) { ss += 0.5*f; } else { ss += f; }
  }
  ss *= dx;

  return ss;
};

double angularIntegral_p_phonon(int p, double alpha, double x)
{
  int l;
  double pol, term, ang;
  double ym = alpha*pow(1.0-x,2);
  double yp = alpha*pow(1.0+x,2);
  pol = 1;
  term = 1; 
  for(l=1;l<=p;l++) {
    term *= ym/l;
    pol += term;
  }
  ang = exp(-ym)*pol;
  //
  pol = 1;
  term = 1; 
  for(l=1;l<=p;l++) {
    term *= yp/l;
    pol += term;
  }
  ang -= exp(-yp)*pol;

  return ang;
};

double totXS_1ph(double kabs, struct IncoherentPhonon_physics_storage_struct *data)
{
  int i, n;
  double f, ym, yp, u, Fp, ss, x, xmin, xmax, dx;
  double E = KS2E*kabs*kabs;
  double Erat = E/(data->Emax);
  double alpha = Erat*(data->mRat)*(data->g0);

  n = 10000;
  if(Erat>1.0) { xmin = sqrt(1.0 - 1.0/Erat); } else { xmin = 0; }
  xmax = sqrt(1.0 + 1.0/Erat);
  dx = (xmax-xmin)/n;

  x = xmin;
  u = Erat*(1.0-x*x);
  Fp = interpFunc(u,data->nF1,data->u1,data->F1);
  if(isnan(Fp)) {
    printf("totXS_1ph: F1 not interpolated first\n");
    exit(1);
  }
  f = x*Fp*angularIntegral_p_phonon(1,alpha,x);
  ss = 0.5*f;
  for(i=1;i<n;i++) {
    x = xmin + i*dx;
    u = Erat*(1.0-x*x);
    Fp = interpFunc(u,data->nF1,data->u1,data->F1);
    if(isnan(Fp)) {
      printf("totXS_1ph: F1 not interpolated i=%d\n",i);
      exit(1);
    }
    f = x*Fp*angularIntegral_p_phonon(1,alpha,x);
    ss += f;
  }
  x = xmax;
  u = Erat*(1.0-x*x);
  Fp = interpFunc(u,data->nF1,data->u1,data->F1);
  if(isnan(Fp)) {
    printf("totXS_1ph: F1 not interpolated last\n");
    exit(1);
  }
  f = x*Fp*angularIntegral_p_phonon(1,alpha,x);
  ss += 0.5*f;

  ss *= dx;
  
  ss *= (data->sigmaCoh+data->sigmaInc)/(2.*(data->mRat)*(data->g0));

  return ss;
};

double totXS_2ph(double kabs, struct IncoherentPhonon_physics_storage_struct *data)
{
  int i, n;
  double f, ym, yp, u, Fp, ss, x, xmin, xmax, dx;
  double E = KS2E*kabs*kabs;
  double Erat = E/(data->Emax);
  double alpha = Erat*(data->mRat)*(data->g0);

  n = 20000;
  if(Erat>2.0) { xmin = sqrt(1.0 - 2.0/Erat); } else { xmin = 0; }
  xmax = sqrt(1.0 + 2.0/Erat);
  dx = (xmax-xmin)/n;

  x = xmin;
  u =Erat*(1.0-x*x);
  Fp = interpFunc(u,data->nF2,data->u2,data->F2);
  if(isnan(Fp)) {
    printf("totXS_2ph: F2 not interpolated first\n");
    exit(1);
  }
  f = x*Fp*angularIntegral_p_phonon(2,alpha,x);
  ss = 0.5*f;
  for(i=1;i<n;i++) {
    x = xmin+i*dx;
    u =Erat*(1.0-x*x);
    Fp = interpFunc(u,data->nF2,data->u2,data->F2);
    if(isnan(Fp)) {
      printf("totXS_2ph: F2 not interpolated i=%d\n",i);
      exit(1);
    }
    f = x*Fp*angularIntegral_p_phonon(2,alpha,x);
    ss += f;
  }
  x = xmax;
  u =Erat*(1.0-x*x);
  Fp = interpFunc(u,data->nF2,data->u2,data->F2);
  if(isnan(Fp)) {
    printf("totXS_2ph: F2 not interpolated last\n");
    exit(1);
  }
  f = x*Fp*angularIntegral_p_phonon(2,alpha,x);
  ss += 0.5*f;

  ss *= dx;
  
  ss *= (data->sigmaCoh+data->sigmaInc)/(2.*(data->mRat)*(data->g0));

  return ss;
};

double totXS_3ph(double kabs, struct IncoherentPhonon_physics_storage_struct *data)
{
  int i, n;
  double f, ym, yp, u, Fp, ss, x, xmin, xmax, dx;
  double E = KS2E*kabs*kabs;
  double Erat = E/(data->Emax);
  double alpha = Erat*(data->mRat)*(data->g0);

  n = 30000;
  if(Erat>3.0) { xmin = sqrt(1.0-3.0/Erat); } else { xmin = 0; }
  xmax = sqrt(1.0 + 3.0/Erat);
  dx = (xmax-xmin)/n;

  x = xmin;
  u =Erat*(1.0-x*x);
  Fp = interpFunc(u,data->nF3,data->u3,data->F3);
  if(isnan(Fp)) {
    printf("totXS_3ph: F3 not interpolated first u=%f\n",u);
    exit(1);
  }
  f = x*Fp*angularIntegral_p_phonon(3,alpha,x);
  ss = 0.5*f;
  for(i=1;i<n;i++) {
    x = xmin + i*dx;
    u =Erat*(1.0-x*x);
    Fp = interpFunc(u,data->nF3,data->u3,data->F3);
    if(isnan(Fp)) {
      printf("totXS_3ph: F3 not interpolated i=%d\n",i);
      exit(1);
    }
      f = x*Fp*angularIntegral_p_phonon(3,alpha,x);
    ss += f;
  }
  x = xmax;
  u =Erat*(1.0-x*x);
  Fp = interpFunc(u,data->nF3,data->u3,data->F3);
  if(isnan(Fp)) {
    printf("totXS_3ph: F3 not interpolated last\n");
    exit(1);
  }
  f = x*Fp*angularIntegral_p_phonon(3,alpha,x);
  ss += 0.5*f;

  ss *= dx;
  
  ss *= (data->sigmaCoh+data->sigmaInc)/(2.*(data->mRat)*(data->g0));

  return ss;
};

void computeFs(struct IncoherentPhonon_physics_storage_struct *data)
{
  int i, compute;
  double du;
  FILE *filep;

  // g0 should have been computed in setParams
  if(data->g0==0) { data->g0 = Gt(0,data); }

  compute = 0;

  filep = fopen("F1.txt","r");
  if(filep!=NULL) {
    fscanf(filep,"%d",&(data->nF1));
    data->u1 = (double *)malloc((data->nF1)*sizeof(double));
    data->F1 = (double *)malloc((data->nF1)*sizeof(double));
    for(i=0;i<data->nF1;i++) {
      fscanf(filep,"%lf %lf",data->u1+i,data->F1+i);
    }
    fclose(filep);
  } else { compute = 1; }

  filep = fopen("F2.txt","r");
  if(filep!=NULL) {
    fscanf(filep,"%d",&(data->nF2));
    data->u2 = (double *)malloc((data->nF2)*sizeof(double));
    data->F2 = (double *)malloc((data->nF2)*sizeof(double));
    for(i=0;i<data->nF2;i++) {
      fscanf(filep,"%lf %lf",data->u2+i,data->F2+i);
    }
    fclose(filep);
  } else { compute = 1; }

  filep = fopen("F3.txt","r");
  if(filep!=NULL) {
    fscanf(filep,"%d",&(data->nF3));
    data->u3 = (double *)malloc((data->nF3)*sizeof(double));
    data->F3 = (double *)malloc((data->nF3)*sizeof(double));
    for(i=0;i<data->nF3;i++) {
      fscanf(filep,"%lf %lf",data->u3+i,data->F3+i);
    }
    fclose(filep);
  } else { compute = 1; }

  if( !compute ) { return; }

  // compute if necessary

  data->nF1 = 1000;
  data->nF2 = 200;
  data->nF3 = 100;

  data->u1 = (double *)malloc((data->nF1+1)*sizeof(double));
  data->F1 = (double *)malloc((data->nF1+1)*sizeof(double));
  data->u2 = (double *)malloc((data->nF2+1)*sizeof(double));
  data->F2 = (double *)malloc((data->nF2+1)*sizeof(double));
  data->u3 = (double *)malloc((data->nF3+1)*sizeof(double));
  data->F3 = (double *)malloc((data->nF3+1)*sizeof(double));

  du = 2./(data->nF1);
  data->nF1++;
  filep = fopen("F1.txt","a");
  fprintf(filep,"%d\n",data->nF1);
  for(i=0;i<data->nF1;i++) {
    (data->u1)[i] = -1.0 + i*du;
    printf("F1: %d %d %f\n",i,data->nF1,(data->u1)[i]);
    (data->F1)[i] = F1((data->u1)[i],data);
    fprintf(filep,"%f %.6e\n",(data->u1)[i],(data->F1)[i]);
    fflush(filep);
  }
  fclose(filep);
  du = 4./(data->nF2);
  data->nF2++;
  filep = fopen("F2.txt","a");
  fprintf(filep,"%d\n",data->nF2);
  for(i=0;i<data->nF2;i++) {
    (data->u2)[i] = -2.0 + i*du;
    printf("F2: %d %d %f\n",i,data->nF2,(data->u2)[i]);
    (data->F2)[i] = F2((data->u2)[i],data);
    fprintf(filep,"%f %.6e\n",(data->u2)[i],(data->F2)[i]);
    fflush(filep);
  }
  fclose(filep);
  du = 6./(data->nF3);
  data->nF3++;
  filep = fopen("F3.txt","a");
  fprintf(filep,"%d\n",data->nF3);
  for(i=0;i<data->nF3;i++) {
    (data->u3)[i] = -3.0 + i*du;
    printf("F3: %d %d %f\n",i,data->nF3,(data->u3)[i]);
    (data->F3)[i] = F3((data->u3)[i],data);
    fprintf(filep,"%f %.6e\n",(data->u3)[i],(data->F3)[i]);
    fflush(filep);
  }
  fclose(filep);
};

double Gu(double u, struct IncoherentPhonon_physics_storage_struct *data)
{
  double E = u*data->Emax;
  double x = E/data->kBT;
  if(fabs(u)<1.0e-7) { return (data->dosPar)*(data->Emax)*(data->Emax)*(data->kBT); } // esto esta bien
  return (data->Emax)*dos(E,data)*bose(x)/u;
};

double bose(double x)
{
  return 1.0/(exp(x)-1.0);
};

double F1(double u, struct IncoherentPhonon_physics_storage_struct *data)
{
  return Gu(-u,data)/(data->g0);
};

double F2(double u, struct IncoherentPhonon_physics_storage_struct *data)
{
  return quadF2(u,data);
};

double F3(double u, struct IncoherentPhonon_physics_storage_struct *data)
{
  return quadF3(u,data);
};

double F2int(double u, double u1, struct IncoherentPhonon_physics_storage_struct *data)
{
  return Gu(u1,data)*Gu(-u-u1,data)/pow(data->g0,2);
};

double F3int(double u, double u1, double u2, struct IncoherentPhonon_physics_storage_struct *data)
{
  return Gu(u1,data)*Gu(u2,data)*Gu(-u-u1-u2,data)/pow(data->g0,3);
};

double quadF2(double u, struct IncoherentPhonon_physics_storage_struct *data)
{
  int n;
  double umin = -1.0;
  double umax = 1.0;
  double g1, g2;
  double tol = data->tolQuadratureFs;

  n = 100;
  g1 = trapezF2(u,n,umin,umax,data);
  n = 200;
  g2 = trapezF2(u,n,umin,umax,data);
  while(n<nFCmax) {
    if(fabs(g1-g2)<tol) {
      return g2;
    } 
    n *= 2;
    g1 = g2;
    g2 = trapezF2(u,n,umin,umax,data);
  }

  printf("quadF2: not converged\n");
  printf("%f %d %.6e %.6e %.16e\n",u,n,g1,g2,g2-g1);
  
  return -sqrt(-1.0);
};

double trapezF2(double u, int n, double umin, double umax, struct IncoherentPhonon_physics_storage_struct *data)
{
  int i;
  double u1, du1, hdu1, s, f1, f2;

  if(n<=0) {
    printf("trapezF2: invalid n = %d\n",n);
    exit(1);
  }

  du1 = (umax-umin)/n;
  hdu1 = 0.5*du1;

  s = 0;
  u1 = umin;
  f1 = F2int(u,u1,data);
  for(i=1;i<=n;i++) {
    u1 += du1;
    f2 = F2int(u,u1,data);
    s += hdu1*(f1+f2);
    f1 = f2;
  }

  return s;
};

double quadF3(double u, struct IncoherentPhonon_physics_storage_struct *data)
{
  int n;
  double umin = -1.0;
  double umax = 1.0;
  double g1, g2;
  double tol = data->tolQuadratureFs;
  
  n = 100;
  g1 = trapezF3(u,n,umin,umax,data);
  n = 200;
  g2 = trapezF3(u,n,umin,umax,data);
  while(n<nFCmax) {
    if(fabs(g1-g2)<tol) {
      return g2;
    } 
    n *= 2;
    g1 = g2;
    g2 = trapezF3(u,n,umin,umax,data);
  }

  printf("quadF3: not converged\n");
  printf("%f %d %.6e %.6e %.16e\n",u,n,g1,g2,g2-g1);
  
  return -sqrt(-1.0);
};

double trapezF3(double u, int n, double umin, double umax, struct IncoherentPhonon_physics_storage_struct *data)
{
  int i;
  double u1, du1, hdu1, s, f1, f2;

  if(n<=0) {
    printf("trapezF3: invalid n = %d\n",n);
    exit(1);
  }

  du1 = (umax-umin)/n;
  hdu1 = 0.5*du1;

  s = 0;
  u1 = umin;
  f1 = quadF3u2(u,u1,data);
  for(i=1;i<=n;i++) {
    u1 += du1;
    f2 = quadF3u2(u,u1,data);
    s += hdu1*(f1+f2);
    f1 = f2;
  }

  return s;
};

double quadF3u2(double u, double u1, struct IncoherentPhonon_physics_storage_struct *data)
{
  int n;
  double umin = -1.0;
  double umax = 1.0;
  double g1, g2;
  double tol = data->tolQuadratureFs;
  
  n = 100;
  g1 = trapezF3u2(u,u1,n,umin,umax,data);
  n = 200;
  g2 = trapezF3u2(u,u1,n,umin,umax,data);
  while(n<nFCmax) {
    if(fabs(g1-g2)<tol) {
      return g2;
    } 
    n *= 2;
    g1 = g2;
    g2 = trapezF3u2(u,u1,n,umin,umax,data);
  }

  printf("quadF3u2: not converged\n");
  printf("%f %f %d %.6e %.6e %.16e\n",u,u1,n,g1,g2,g2-g1);
  
  return -sqrt(-1.0);
};

double trapezF3u2(double u, double u1, int n, double umin, double umax, struct IncoherentPhonon_physics_storage_struct *data)
{
  int i;
  double u2, du2, hdu2, s, f1, f2;

  if(n<=0) {
    printf("trapezF3u2: invalid n = %d\n",n);
    exit(1);
  }

  du2 = (umax-umin)/n;
  hdu2 = 0.5*du2;

  s = 0;
  u2 = umin;
  f1 = F3int(u,u1,u2,data);
  for(i=1;i<=n;i++) {
    u2 += du2;
    f2 = F3int(u,u1,u2,data);
    s += hdu2*(f1+f2);
    f1 = f2;
  }

  return s;
};

//////////////////////////
// Multi-phonon term   ///
//////////////////////////

void sample_Kprime_and_Dir_mph(double kabs, double *x, double *z, struct IncoherentPhonon_physics_storage_struct *data)
{
  // x = kprime/kabs
  // z = cos(theta)
  int i;
  double u, Q2, x2;
  double E = KS2E*kabs*kabs;
  double Erat = E/(data->Emax);
  double iErat = 1./Erat;
  double iEMrat = iErat/(data->mRat);
  // rejection method
  //for(i=0;i<maxIter;i++) {
  while(1) {
    u = sample_u_mph(Erat,data);
    if(isnan(u)) { 
      printf("u nan: %f %f %f\n",kabs,E,Erat);
    }
    x2 = 1.0 - iErat*u;
    if(x2<=0) { continue; }
    *x = sqrt(x2);
    Q2 = sample_Q2_mph(u,Erat,data);
    *z = (1.0 + x2 - iEMrat*Q2)/(2*(*x));
    if(fabs(*z)<=1) { return; }
  }
  *x = -sqrt(-1.0);
  *z = -sqrt(-1.0);
};

double sample_u_mph(double umax, struct IncoherentPhonon_physics_storage_struct *data)
{
  int i;
  double u, f, fmax, a1, a2;
  int np = data->np_u_mph;
  double *up = data->u;
  double *xs = data->dXSdu_mph;
  double umin = up[0];
  double du = (umax - umin);

  if(umax>up[np-1]) {
    a1 = (pow(up[np-2],1)*(2*PI-xs[np-1])-pow(up[np-2],2)*(2*PI-xs[np-2]))/(up[np-1]-up[np-2]);
    a2 = pow(up[np-2],2)*(2*PI-xs[np-2]) - a1*up[np-2];
    fmax = 2.*PI - a1/umax - a2/(umax*umax);
  } else {
    fmax = interpFunc(umax,np,up,xs);
  }

  // rejection method
  //for(i=0;i<maxIter;i++) {
  while(1) {
    u = umin + rand01()*du;
    if(u>up[np-1]) { f = 2.*PI - a1/u - a2/(u*u); } else { f = interpFunc(u,np,up,xs); }
    if(f/fmax>rand01()) { return u; }
  }
  printf("sample_u_mph: maxIter reached\n");
  printf("sample_u_mph: %f %f %f %.6e\n",umin,umax,up[np-1],fmax);
  return -sqrt(-1.0);
};

double sample_Q2_mph(double u, double Erat, struct IncoherentPhonon_physics_storage_struct *data)
{
  int i;
  int np = data->np_u_mph;
  double Q2, f, fmax, Q2m;
  double x, x2, Q2min, Q2max;
  double q1, q2, u1, u2;
  double dQ2;

  x2 = 1.0 - u/Erat;
  if(x2<0) { return -sqrt(-1.0); }
  x = sqrt(x2);
  //the commented lines are wrong. The conservation laws cannot be enforced here: 
  //the distribution would be biased
  //Q2min = Erat*(data->mRat)*pow(1.0-x,2);
  //Q2max = Erat*(data->mRat)*pow(1.0+x,2);

  // obtain fmax
  if(u<(data->u)[0]) {
    fmax =  interpFunc(u,np,data->u,data->dXSdQ2_Fmax_mph);
    Q2m =  interpFunc(u,np,data->u,data->dXSdQ2_Q2max_mph);
    fmax = (data->dXSdQ2_Fmax_mph)[data->np_u_mph-1];
    printf("u<data->u[0]\n");
  } else if (u>(data->u)[np-1]) {
    u1 = (data->u)[np-1];
    u2 = (data->u)[np-2];
    q1 = (data->dXSdQ2_Q2max_mph)[np-1];
    q2 = (data->dXSdQ2_Q2max_mph)[np-2];
    Q2m = q1 + (q2-q1)*((u-u1)/(u2-u1));
    Q2min = (data->Q2min)[np-1];
    q1 = (data->Q2max)[np-1];
    q2 = (data->Q2max)[np-2];
    Q2max = q1 + (q2-q1)*((u-u1)/(u2-u1));
    // fmax is overstimated, but it is best like this
    fmax = (data->dXSdQ2_Fmax_mph)[data->np_u_mph-1];
  } else {
    fmax =  interpFunc(u,np,data->u,data->dXSdQ2_Fmax_mph);
    Q2m =  interpFunc(u,np,data->u,data->dXSdQ2_Q2max_mph);
    Q2min =  interpFunc(u,np,data->u,data->Q2min);
    Q2max =  interpFunc(u,np,data->u,data->Q2max);
 }

  if(Q2m<Q2min || Q2m>Q2max) {
    // the maximum is attained at the borders
    fmax = SFuncInterp(Q2min,u/Q2min,data);
    if(isnan(fmax)) {
      printf("isnan Q2min\n");
      printf("%f %f %.6e\n",u,Q2min,u/Q2min);
      exit(1);
    }
    f = SFuncInterp(Q2max,u/Q2max,data);
    if(isnan(f)) {
      printf("isnan Q2max\n");
      printf("%f %f %.6e\n",u,Q2max,u/Q2max);
      exit(1);
    }
    if(f>fmax) { fmax = f; }
  }

  dQ2 = Q2max - Q2min;

  // rejection method
  //for(i=0;i<maxIter;i++) {
  while(1) {
    Q2 = Q2min + rand01()*dQ2;
    f = SFuncInterp(Q2,u/Q2,data);
    if(isnan(f)) {
      printf("isnan Q2\n");
      printf("%f %f %.6e\n",u,Q2,u/Q2);
      exit(1);
    }
    if(f/fmax>rand01()) { return Q2; }
  }
  printf("sample_Q2_mph: maxIter reached\n");
  return -sqrt(-1.0);
};

void compute_dXSdu_mph(struct IncoherentPhonon_physics_storage_struct *data)
{
  int i, np, np1, np2;
  double u, du, umin, umax, xs, u1, u2, r;
  double xsTol = data->tol_dXSdu_mph;
  FILE *filep;

  // look for umin
  u = -1;
  xs = quad_dXSdu_mph(u,data);
  while(xs>xsTol) {
    u -= 1;
    xs = quad_dXSdu_mph(u,data);
  }
  umin = u;
  printf("umin: %f\n",umin);
  // look for umax
  u = 0;
  xs = quad_dXSdu_mph(u,data);
  while(fabs(xs-2*PI)>0.01) {
    u += 1;
    xs = quad_dXSdu_mph(u,data);
  }
  umax = u;
  printf("umax: %f\n",umax);

  u = 0;
  xs = quad_dXSdu_mph(u,data);
  while(xs>0.01) {
    u -= 0.1;
    xs = quad_dXSdu_mph(u,data);
  }
  u1 = u;
  printf("u1: %f\n",u1);

  u = 0;
  xs = quad_dXSdu_mph(u,data);
  while(fabs(xs-2*PI)>0.08) {
    u += 0.1;
    xs = quad_dXSdu_mph(u,data);
  }
  u2 = u;
  printf("u2: %f\n",u2);

  np = data->np_u_mph;

  r = 0.1; // u resolution between u1 and u2 (r*du)
  np1 = (int)round(np/(1-r+r*(umax-umin)/(u2-u1)));
  np2 = np - np1;

  du = (u2 - u1)/(r*np1);

  data->u = (double *)malloc(np*sizeof(double));
  data->dXSdu_mph = (double *)malloc(np*sizeof(double));

  filep = fopen("dXSdu_mph.txt","w");
  u = umin;
  for(i=0;i<np;i++) {
    xs = quad_dXSdu_mph(u,data);
    if(isnan(xs)) { printf("u: %f\n",u); exit(1); }
    (data->u)[i] = u;
    (data->dXSdu_mph)[i] = xs;
    fprintf(filep,"%f %.6e\n",(data->u)[i],(data->dXSdu_mph)[i]);
    fflush(filep);
    if((u<u1 && fabs(u-u1)>r*du) || u>=u2) { u += du; } else { u += r*du; } 
  }
  fclose(filep);
};

double quad_dXSdu_mph(double u, struct IncoherentPhonon_physics_storage_struct *data)
{
  int n;
  double Q2max, s1, s2, sq1, sq2;
  double xsTol = data->tol_dXSdu_mph;

  Q2max = 50;
  if(Q2max<2*u) { Q2max = 2*u; }

  n = 100;
  s1 = trapez_dXSdu_mph(u,n,Q2max,data);
  if(isnan(s1)) { printf("quad_dXSdu_mph nan for u = %f\n",u); return -sqrt(-1.0); }

  n *= 2;
  s2 = trapez_dXSdu_mph(u,n,Q2max,data);
  if(isnan(s2)) { printf("quad_dXSdu_mph nan for u = %f\n",u); return -sqrt(-1.0); }
  while(fabs(s2-s1)>xsTol) {
    n *= 2;
    if(n>nFCmax) { 
      printf("quad_dXSdu_mph a: n>nFCmax for u = %f Q2max = %.6e\n",u,Q2max);
      printf("%.6e %.6e %.6e\n",s2,s1,s2-s1);
      exit(1);
    }
    s1 = s2;
    s2 = trapez_dXSdu_mph(u,n,Q2max,data);
    if(isnan(s2)) { printf("quad_dXSdu_mph nan for u = %f\n",u); return -sqrt(-1.0); }
  }
  sq1 = s2;
  Q2max *= 2;
  n = n/2;
  s1 = trapez_dXSdu_mph(u,n,Q2max,data);
  if(isnan(s1)) { printf("quad_dXSdu_mph nan for u = %f\n",u); return -sqrt(-1.0); }
  n *= 2;
  s2 = trapez_dXSdu_mph(u,n,Q2max,data);
  if(isnan(s2)) { printf("quad_dXSdu_mph nan for u = %f\n",u); return -sqrt(-1.0); }
  while(fabs(s2-s1)>xsTol) {
    n *= 2;
    if(n>nFCmax) { 
      printf("quad_dXSdu_mph b: n>nFCmax for u = %f Q2max = %.6e\n",u,Q2max); 
      printf("%.6e %.6e %.6e\n",s2,s1,s2-s1);
      exit(1); 
    }
    s1 = s2;
    s2 = trapez_dXSdu_mph(u,n,Q2max,data);
    if(isnan(s2)) { printf("quad_dXSdu_mph nan for u = %f\n",u); return -sqrt(-1.0); }
  }
  sq2 = s2;
  
  while(fabs(sq2-sq1)>xsTol) {
    Q2max *= 2;
    sq1 = sq2;
    n = n/2;
    s1 = trapez_dXSdu_mph(u,n,Q2max,data);
    if(isnan(s1)) { printf("quad_dXSdu_mph nan for u = %f\n",u); return -sqrt(-1.0); }
    n *= 2;
    s2 = trapez_dXSdu_mph(u,n,Q2max,data);
    if(isnan(s2)) { printf("quad_dXSdu_mph nan for u = %f\n",u); return -sqrt(-1.0); }
    while(fabs(s2-s1)>xsTol) {
      n *= 2;
      if(n>nFCmax) {
	printf("quad_dXSdu_mph c: n>nFCmax for u = %f Q2max = %.6e\n",u,Q2max);
	printf("%.6e %.6e %.6e\n",s2,s1,s2-s1);
	exit(1);
      }
      s1 = s2;
      s2 = trapez_dXSdu_mph(u,n,Q2max,data);
      if(isnan(s2)) { printf("quad_dXSdu_mph nan for u = %f\n",u); return -sqrt(-1.0); }
    }
    sq2 = s2;
  }

  return sq2;
};

double trapez_dXSdu_mph(double u, int n, double Q2max, struct IncoherentPhonon_physics_storage_struct *data)
{
  int i;
  double Q2, dQ2, S, sum;

  dQ2 = Q2max/n;
  Q2 = 0;
  sum = 0;
  for(i=0;i<=n;i++) {
    S = SFuncInterp(Q2,u/Q2,data);
    if(isnan(S)) { return -sqrt(-1.0); }  
    if(i!=0 && i!=n) { sum += S; } else { sum += 0.5*S; }
    Q2 += dQ2;
  }
  sum *= dQ2;

  return sum;
};

void compute_dXSdQ2_max_mph(struct IncoherentPhonon_physics_storage_struct *data)
{
  int i, j, n;
  double u, xs, Q2, dQ2, fmax;
  double *pQ2, *pfm, *Q2min, *Q2max;
  int np = data->np_u_mph;
  FILE *filep;

  pQ2 = (double *)malloc(np*sizeof(double));
  pfm = (double *)malloc(np*sizeof(double));
  Q2min = (double *)malloc(np*sizeof(double));
  Q2max = (double *)malloc(np*sizeof(double));

  n = 10000;
  dQ2 = 50./n;

  filep = fopen("dXSdQ2_mph.txt","w");
  for(i=0;i<np;i++) {
    u = (data->u)[i];
    pfm[i] = -1.0;
    pQ2[i] = 0;
    for(j=0;j<n;j++) {
      Q2 = j*dQ2;
      xs = SFuncInterp(Q2,u/Q2,data);
      fprintf(filep,"%d %f %f %.6e\n",i,u,Q2,xs);
      if(xs>pfm[i]) { pfm[i] = xs; pQ2[i] = Q2; }
    }
    fprintf(filep,"\n\n");
    fflush(filep);
    // limits
    Q2min[i] = 0;
    Q2 = pQ2[i];
    while(1) {
      Q2 -= dQ2;
      if(Q2<=0) { break; }
      xs = SFuncInterp(Q2,u/Q2,data);
      if(xs/pfm[i] < 1.0e-6) { Q2min[i] = Q2; break; } 
    }
    Q2 = pQ2[i];
    while(1) {
      Q2 += dQ2;
      xs = SFuncInterp(Q2,u/Q2,data);
      if(xs/pfm[i] < 1.0e-6) { Q2max[i] = Q2; break; } 
    }
  }
  fclose(filep);


  data->dXSdQ2_Q2max_mph = pQ2;
  data->dXSdQ2_Fmax_mph = pfm;
  data->Q2min = Q2min;
  data->Q2max = Q2max;

  filep = fopen("dXSdQ2_max_mph.txt","w");
  for(i=0;i<np;i++) {
    fprintf(filep,"%f %.6e %.6e %.6e %.6e\n",(data->u)[i],(data->Q2min)[i],(data->Q2max)[i],
	    (data->dXSdQ2_Q2max_mph)[i],(data->dXSdQ2_Fmax_mph)[i]);
  }
  fclose(filep);
};

double totXS_mph(double kabs, struct IncoherentPhonon_physics_storage_struct *data)
{
  // x = kprime/k
  // z = cos(theta)
  int i, j, nx, nz, num;
  double E, x, xmin, xmax, dx, z, dz, u, Q2, tsp, Erat, Q2f;
  double S, s1, ss;
  double Se, s1e;
  double stol = 1.0e-8;
  FILE *filep;

  E = KS2E*kabs*kabs;

  Erat = E/(data->Emax);
  Q2f = Erat*(data->mRat);

  nz = 1000;
  dz = 2./nz;

  // calculate xmin and xmax
  dx = 0.01;
  x = 1;
  num = 0;
  while(1) {
    u = Erat*(1.0 - x*x);
    s1 = 0;
    s1e = 0;
    for(j=0;j<=nz;j++) {
      z = -1.0 + j*dz;
      Q2 = Q2f*(1.0 + x*x - 2.0*x*z);
      if(Q2<1.0e-8) { S = 0; } else { S = SFuncInterp(Q2,u/Q2,data); }
      if(isnan(S)) {
	printf("%f %f %.6e %.6e %.6e\n",x,z,u,Q2,S);
	exit(1);
      }
      if(j!=0 && j!=nz) { s1 += S; s1e += Se; } else { s1 += 0.5*S; s1e += 0.5*Se; }
    }
    if(x*x*dz*s1<stol) { xmin = x; break; }
    x -= dx;
  }
  x = 1.0 + dx;
  while(1) {
    u = Erat*(1.0 - x*x);
    s1 = 0;
    s1e = 0;
    for(j=0;j<=nz;j++) {
      z = -1.0 + j*dz;
      Q2 = Q2f*(1.0 + x*x - 2.0*x*z);
      if(Q2<1.0e-8) { S = 0; } else { S = SFuncInterp(Q2,u/Q2,data); }
      if(isnan(S)) {
	printf("%f %f %.6e %.6e %.6e\n",x,z,u,Q2,S);
	exit(1);
      }
      if(j!=0 && j!=nz) { s1 += S; s1e += Se; } else { s1 += 0.5*S; s1e += 0.5*Se; }
    }
    if(x*x*dz*s1<stol) { xmax = x; break; }
    x += dx;
  }

  filep = fopen("xlim.txt","a");
  fprintf(filep,"%.6e %.6e %.6e %.6e\n",kabs,E,xmin,xmax);
  fclose(filep);

  nx = 1000;
  dx = (xmax-xmin)/nx;

  ss = 0;
  for(i=0;i<=nx;i++) {
    x = xmin + i*dx;
    u = Erat*(1.0 - x*x);
    s1 = 0;
    for(j=0;j<=nz;j++) {
      z = -1.0 + j*dz;
      Q2 = Q2f*(1.0 + x*x - 2.0*x*z);
      if(Q2<1.0e-8) { S = 0; } else { S = SFuncInterp(Q2,u/Q2,data); }
      if(isnan(S)) {
	printf("%f %f %.6e %.6e %.6e\n",x,z,u,Q2,S);
	exit(1);
      }
      if(j!=0 && j!=nz) { s1 += S; } else { s1 += 0.5*S; }
    }
    if(i!=0 && i!=nx) { ss += x*x*dz*s1; } else { ss += 0.5*x*x*dz*s1; }
  }
  ss *= dx*Erat;

  ss *= (data->sigmaCoh+data->sigmaInc)/(2*PI);

  return ss;
};

double dXSdxdz_mph(double kabs, double x, double z, struct IncoherentPhonon_physics_storage_struct *data)
{
  // x = kprime/k
  // z = cos(theta)
  double xs;
  double E = KS2E*kabs*kabs;
  double Erat = E/(data->Emax);
  double u = Erat*(1.0 - x*x);
  double Q2 = Erat*(data->mRat)*(1.0 + x*x - 2.0*x*z);
  if(Q2<1.0e-8) { return 0; }
  xs = Erat*(x*x/PI)*SFuncInterp(Q2,u/Q2,data);
  return xs;
};

double dXSdx_mph(double kabs, double x, struct IncoherentPhonon_physics_storage_struct *data)
{
  // x = kprime/k
  // z = cos(theta)
  int i, n = 200000;
  double z, dz, f, ss;

  dz = 2.0/n;
  ss = 0;
  for(i=1;i<n;i++) {
    z = -1.0 + i*dz;
    f = dXSdxdz_mph(kabs,x,z,data);
    if(i==0 || i==n) { ss += 0.5*f; } else { ss += f; }
  }
  ss *= dz;

  return ss;
};

double dXSdz_mph(double kabs, double z, struct IncoherentPhonon_physics_storage_struct *data)
{
  // x = kprime/k
  // z = cos(theta)
  int i, n = 100000;
  double x, xmax, dx, f, ss;

  xmax = 10;
  dx = xmax/n;
  ss = 0;
  for(i=0;i<=n;i++) {
    x = i*dx;
    f = dXSdxdz_mph(kabs,x,z,data);
    if(i==0 || i==n) { ss += 0.5*f; } else { ss += f; }
  }
  ss *= dx;

  return ss;
};

double SFunc(double Q2, double xi, struct IncoherentPhonon_physics_storage_struct *data)
{
  // xi = u/Q2
  double tsp, g, g0, d2g, Q2g, S, taylor, mono;
  int l;
  int nsubs=3;

  if(Q2<=0) { return 0; }

  tsp = saddlePoint(xi,data);
  g = Gt(tsp,data);
  g0 = data->g0;
  d2g = d2Gt(tsp,data);

  /*
  Q2g = Q2*g;
  S = sqrt(2.*PI/(Q2*d2g))*exp(Q2*(xi*tsp+g-g0));
  S *= 1.- exp(-Q2g)*(1. + Q2g + 0.5*Q2g*Q2g + pow(Q2g,3)/6.);
  */

  Q2g = Q2*g;
  taylor = 1 + Q2g;
  mono = Q2g;
  for(l=2;l<=nsubs;l++) {
    mono *= Q2g/l;
    taylor += mono;
  }
  S = sqrt(2.*PI/(Q2*d2g))*exp(Q2*(xi*tsp+g-g0))*( 1. - exp(-Q2g + log(taylor)) );

  return S;
};

double SFuncInterp(double Q2, double xi, struct IncoherentPhonon_physics_storage_struct *data)
{
  // xi = u/Q2
  double tsp, g, g0, d2g, H, Q2H, Q2g, S, taylor, mono;
  int l;
  int nsubs=3;

  if(Q2<=0) { return 0; }

  g0 = data->g0;
  tspInterp(xi,&tsp,&g,&d2g,&H,data);
  // it is much better to interpolate the function H than computing it from interpolated values
  //H = xi*tsp + g - g0;
  if(fabs(xi-1)<0.2) {
    H = -0.5*pow(xi-1,2)/(data->d2g0) + (data->aH3)*pow(xi-1,3) + (data->aH4)*pow(xi-1,4);
  }

  Q2H = Q2*H;
  if(Q2H<-35) { return 0; }

  if(Q2H>0) { 
    printf("SFuncInterp: positive Q2H %.6e\n",Q2H);
    printf("SFuncInterp: %.6e %.6e %.6e %.6e %.6e %.6e\n",Q2,xi,tsp,g,d2g,xi*tsp+g-g0);
  }

  Q2g = Q2*g;
  taylor = 1 + Q2g;
  mono = Q2g;
  for(l=2;l<=nsubs;l++) {
    mono *= Q2g/l;
    taylor += mono;
  }
  S = sqrt(2.*PI/(Q2*d2g))*exp(Q2H)*( 1. - exp(-Q2g + log(taylor)) );

  if(isnan(S)) {
    printf("SFuncInterp:\n");
    printf("%.6e %.6e %.6e %.6e %.6e %.6e\n",Q2,xi,tsp,g,d2g,H);
  }

  return S;
};

void computeSaddlePointSol(int ntsp, double ximin, double ximax, struct IncoherentPhonon_physics_storage_struct *data)
{
  int i, done1, doneXi1, doneXi2;
  double xi, dxi, dximax, *xi_, *tsp_, *g_, *d2g_, *H_;
  double xi1, tsp1, g1, d2g1, H1, r1;
  double xi2, tsp2, g2, d2g2, H2, r2;
  FILE *filep;

  filep = fopen("sp.txt","r");
  if(filep != NULL) {
    fscanf(filep,"%d",&ntsp);
    fscanf(filep,"%lf %lf",&(data->xi1),&(data->xi2));
    fscanf(filep,"%lf",&(data->aH3));
    fscanf(filep,"%lf",&(data->aH4));
    xi_ = (double *)malloc(ntsp*sizeof(double));
    tsp_ = (double *)malloc(ntsp*sizeof(double));
    g_ = (double *)malloc(ntsp*sizeof(double));
    d2g_ = (double *)malloc(ntsp*sizeof(double));
    H_ = (double *)malloc(ntsp*sizeof(double));
    for(i=0;i<ntsp;i++) {
      fscanf(filep,"%lf %lf %lf %lf %lf",xi_+i,tsp_+i,g_+i,d2g_+i,H_+i);
    }
    fclose(filep);
    data->ntsp = ntsp;
    data->xi = xi_;
    data->tsp = tsp_;
    data->g = g_;
    data->d2g = d2g_;
    data->H = H_;
    fprintf(data->filep,"final ntsp: %d\n",data->ntsp);
    fprintf(data->filep,"final ximin: %f\n",(data->xi)[0]);
    fprintf(data->filep,"final ximax: %f\n",(data->xi)[(data->ntsp)-1]);
    fflush(data->filep);
    return;
  }

  // computing if necessary
  printf("Computing saddle point solution...\n");

  // around xi = 1;
  xi1 = data->xi1;
  tsp1 = saddlePoint(xi1,data);
  g1 = Gt(tsp1,data);
  d2g1 = d2Gt(tsp1,data);
  H1 = xi1*tsp1 + g1 - (data->g0);
  
  xi2 = data->xi2;
  tsp2 = saddlePoint(xi2,data);
  g2 = Gt(tsp2,data);
  d2g2 = d2Gt(tsp2,data);
  H2 = xi2*tsp2 + g2 - (data->g0);
  
  r1 = H1 + (0.5/(data->d2g0))*pow(xi1-1,2);
  r1 /= pow(xi1-1,3);
  r2 = H2 + (0.5/(data->d2g0))*pow(xi2-1,2);
  r2 /= pow(xi2-1,3);
  
  data->aH4 = (r1 -r2)/(xi1 -xi2);
  data->aH3 = r1 - (xi1-1)*data->aH4;
  
  fprintf(data->filep,"xi1: %f\n",data->xi1);
  fprintf(data->filep,"xi2: %f\n",data->xi2);
  fprintf(data->filep,"aH3: %f\n",data->aH3);
  fprintf(data->filep,"aH4: %f\n",data->aH4);
  fflush(data->filep);
  
  ///////////
  
  if(ntsp<=0) {
    printf("computeSaddlePointSol: invalid ntsp %d\n",ntsp);
    fprintf(data->filep,"computeSaddlePointSol: invalid ntsp %d\n",ntsp);
    exit(1);
  }
  
  dximax = (ximax - ximin)/ntsp;
  
  xi1 = 0.5;
  xi2 = 1.5;
  
  // count ntsp
  ntsp = 0;
  xi = ximin;
  while(xi<ximax) {
    if( !done1 && (fabs(xi-1)<0.05*dximax || (xi-dxi <= 1 && xi >= 1)) ) {
      done1 = 1;
      ntsp++;
      if(fabs(xi-1) > 0.05*dximax) { continue; /* one point added */ } 
    } else if ( !doneXi1 && (fabs(xi-data->xi1)<0.05*dximax || (xi-dxi <= data->xi1 && xi >= data->xi1)) ) {
      doneXi1 = 1;
      ntsp++;
      if(fabs(xi-data->xi1) > 0.05*dximax) { continue; /* one point added */ }
    } else if ( !doneXi2 && (fabs(xi-data->xi2)<0.05*dximax || (xi-dxi <= data->xi2 && xi >= data->xi2)) ) {
      doneXi2 = 1;
      ntsp++;
      if(fabs(xi-data->xi2) > 0.05*dximax) { continue; /* one point added */ } 
    } else {
      ntsp++;
    }     
    if( (xi<xi1 && fabs(xi-xi1)>1.0e-8) || xi>xi2 || fabs(xi-xi2)<1.0e-8) { 
      dxi = dximax; 
    } else {
      dxi = 0.1*dximax;
      }
    xi += dxi;
  }
  if(fabs(xi-ximax)<1.0e-8) { ntsp++; }
  
  xi_ = (double *)malloc(ntsp*sizeof(double));
  tsp_ = (double *)malloc(ntsp*sizeof(double));
  g_ = (double *)malloc(ntsp*sizeof(double));
  d2g_ = (double *)malloc(ntsp*sizeof(double));
  H_ = (double *)malloc(ntsp*sizeof(double));
  
  filep = fopen("sp.txt","w");
  fprintf(filep,"%d\n",ntsp);
  fprintf(filep,"%f %f\n",data->xi1,data->xi2);
  fprintf(filep,"%.16e\n",data->aH3);
  fprintf(filep,"%.16e\n",data->aH4);
  xi = ximin;
  done1 = 0;
  doneXi1 = 0;
  doneXi2 = 0;
  for(i=0;i<ntsp;i++) {
    printf("%d %d\n",i,ntsp);
    if( !done1 && (fabs(xi-1)<0.05*dximax || (xi-dxi <= 1 && xi >= 1)) ) {
      done1 = 1;
      xi_[i] = 1;
      tsp_[i] = 0;
      g_[i] = Gt(tsp_[i],data);
      d2g_[i] = d2Gt(tsp_[i],data);
      H_[i] = xi_[i]*tsp_[i] + g_[i] - (data->g0);
      fprintf(filep,"%.16e %.16e %.16e %.16e %.16e\n",xi_[i],tsp_[i],g_[i],d2g_[i],H_[i]);
      fflush(filep);
    } else if ( !doneXi1 && (fabs(xi-data->xi1)<0.05*dximax || (xi-dxi <= data->xi1 && xi >= data->xi1)) ) {
      doneXi1 = 1;
      xi_[i] = data->xi1;
      tsp_[i] = saddlePoint(xi_[i],data);
      g_[i] = Gt(tsp_[i],data);
      d2g_[i] = d2Gt(tsp_[i],data);
      H_[i] = xi_[i]*tsp_[i] + g_[i] - (data->g0);
      fprintf(filep,"%.16e %.16e %.16e %.16e %.16e\n",xi_[i],tsp_[i],g_[i],d2g_[i],H_[i]);
      fflush(filep);
    } else if ( !doneXi2 && (fabs(xi-data->xi2)<0.05*dximax || (xi-dxi <= data->xi2 && xi >= data->xi2)) ) {
      doneXi2 = 1;
      xi_[i] = data->xi2;
      tsp_[i] = saddlePoint(xi_[i],data);
      g_[i] = Gt(tsp_[i],data);
      d2g_[i] = d2Gt(tsp_[i],data);
      H_[i] = xi_[i]*tsp_[i] + g_[i] - (data->g0);
      fprintf(filep,"%.16e %.16e %.16e %.16e %.16e\n",xi_[i],tsp_[i],g_[i],d2g_[i],H_[i]);
      fflush(filep);
    } else {
      xi_[i] = xi;
      tsp_[i] = saddlePoint(xi_[i],data);
      g_[i] = Gt(tsp_[i],data);
      d2g_[i] = d2Gt(tsp_[i],data);
      H_[i] = xi_[i]*tsp_[i] + g_[i] - (data->g0);
      fprintf(filep,"%.16e %.16e %.16e %.16e %.16e\n",xi_[i],tsp_[i],g_[i],d2g_[i],H_[i]);
      fflush(filep);
    }     
    if( (xi<xi1 && fabs(xi-xi1)>1.0e-8) || xi>xi2 || fabs(xi-xi2)<1.0e-8) { 
      dxi = dximax; 
    } else {
      dxi = 0.1*dximax;
    }
    xi += dxi;
  }
  fclose(filep);

  data->ntsp = ntsp;
  data->xi = xi_;
  data->tsp = tsp_;
  data->g = g_;
  data->d2g = d2g_;
  data->H = H_;

  fprintf(data->filep,"final ntsp: %d\n",data->ntsp);
  fprintf(data->filep,"final ximin: %f\n",(data->xi)[0]);
  fprintf(data->filep,"final ximax: %f\n",(data->xi)[(data->ntsp)-1]);
  fflush(data->filep);
};

void tspInterp(double xi, double *tsp, double *g, double *d2g, double *H, struct IncoherentPhonon_physics_storage_struct *data)
{
  int i, imin, imax;
  double a;
  int ntsp_ = data->ntsp;
  double *xi_ = data->xi;
  double *tsp_ = data->tsp;
  double *g_ = data->g;
  double *d2g_ = data->d2g;
  double *H_ = data->H;
  double a0, a2, a4, a6, a8, a10;
  double b0, b1, b3, b5, b7, b9, b11;

  if(xi<xi_[0]) { 
    *tsp = tsp_[0] + log(xi/xi_[0]) + 1.5*log(log(-xi)/log(-xi_[0]));
    a = (xi-xi_[0])/(xi_[1]-xi_[0]);
    *g = g_[0] + a*(g_[1]-g_[0]);
    *d2g = d2g_[0] + a*(d2g_[1]-d2g_[0]);
    *H = H_[0] + a*(H_[1]-H_[0]);
    return;
  }
  if(xi>xi_[ntsp_-1]) { 
    *tsp = tsp_[ntsp_-1] - log(xi/xi_[ntsp_-1]) - 1.5*log(log(xi)/log(xi_[ntsp_-1]));
    a = (xi-xi_[ntsp_-1])/(xi_[ntsp_-2]-xi_[ntsp_-1]);
    *g = g_[ntsp_-1] + a*(g_[ntsp_-2]-g_[ntsp_-1]); 
    *d2g = d2g_[ntsp_-1] + a*(d2g_[ntsp_-2]-d2g_[ntsp_-1]);
    *H = H_[ntsp_-1] + a*(H_[ntsp_-2]-H_[ntsp_-1]); 
    return;
  }

  // linear interpolation otherwise
  imin=0; imax=ntsp_-1;
  while(imax-imin>1) {
    i = (imax + imin)/2;
    if (xi<xi_[i]) { imax = i; } else { imin = i; }
  }

  if(imax==imin) { printf("imax = imin %d %d\n",imin,imax); exit(1); }
  if(xi<xi_[imin] || xi>xi_[imax]) { 
    printf("bad bracketing: %d %d %f %f %f\n",imin,imax,xi_[imin],xi,xi_[imax]);
    exit(1);
  }

  a = (xi-xi_[imin])/(xi_[imax]-xi_[imin]);

  *tsp = tsp_[imin] + a*(tsp_[imax]-tsp_[imin]);
  *g = g_[imin] + a*(g_[imax]-g_[imin]);
  *d2g = d2g_[imin] + a*(d2g_[imax]-d2g_[imin]);
  *H = H_[imin] + a*(H_[imax]-H_[imin]);
};

double saddlePoint(double xi, struct IncoherentPhonon_physics_storage_struct *data)
{
  // solves dgt(tsp) = -z for tsp
  double tl, th, tm, y;
  double tol;

  tol = data->tolSaddlePoint;

  tl = -1;
  y = dGt(tl,data) + xi;
  while(y>0) {
    tl *= 2;
    y = dGt(tl,data) + xi;
  }

  th = 1;
  y = dGt(th,data) + xi;
  while(y<0) {
    th *= 2;
    y = dGt(th,data) + xi;
  }

  while(th-tl>tol) {
    tm = 0.5*(tl + th);
    y = dGt(tm,data) + xi;
    if(y<0) { tl = tm; } else { th = tm; }
  }

  return 0.5*(tl+th);
};

double Gt(double ti, struct IncoherentPhonon_physics_storage_struct *data)
{
  return quad_mp(ti,data,Gtint);
};

double dGt(double ti, struct IncoherentPhonon_physics_storage_struct *data)
{
  return quad_mp(ti,data,dGtint);
};

double d2Gt(double ti, struct IncoherentPhonon_physics_storage_struct *data)
{
  return quad_mp(ti,data,d2Gtint);
};

double Gtint(double u, double ti, struct IncoherentPhonon_physics_storage_struct *data)
{
  double E = u*data->Emax;
  double x = E/data->kBT;
  if(fabs(u)<1.0e-7) { return (data->dosPar)*(data->Emax)*(data->Emax)*(data->kBT); }
  return (data->Emax)*dos(E,data)*bose(x)*exp(u*ti)/u;
};

double dGtint(double u, double ti, struct IncoherentPhonon_physics_storage_struct *data)
{
  double E = u*data->Emax;
  double x = E/data->kBT;
  if(fabs(u)<1.0e-14) { (data->dosPar)*(data->Emax)*(data->Emax)*(data->kBT)*u; }
  return (data->Emax)*dos(E,data)*bose(x)*exp(u*ti);
};

double d2Gtint(double u, double ti, struct IncoherentPhonon_physics_storage_struct *data)
{
  double E = u*data->Emax;
  double x = E/data->kBT;
  if(fabs(u)<1.0e-6) { (data->dosPar)*(data->Emax)*(data->Emax)*(data->kBT)*u*u; }
  return (data->Emax)*dos(E,data)*bose(x)*u*exp(u*ti);
};

double quad_mp(double ti, struct IncoherentPhonon_physics_storage_struct *data, double (*func)(double,double,struct IncoherentPhonon_physics_storage_struct *))
{
  int n;
  double umin = -1.0;
  double umax = 1.0;
  double g1, g2;
  double tol, relTol;

  tol = data->tolQuadratureGs;

  n = 100;
  g1 = trapez_mp(n,umin,umax,ti,data,func);
  n = 200;
  g2 = trapez_mp(n,umin,umax,ti,data,func);
  while(n<nFCmax) {
    if(fabs(0.5*(g1+g1))<10) { relTol = tol; } else { relTol = tol*fabs(0.5*(g1+g2)); }
    if(fabs(g2-g1)<relTol) {
      return g2;
    } 
    n *= 2;
    g1 = g2;
    g2 = trapez_mp(n,umin,umax,ti,data,func);
  }

  printf("quad: not converged\n");
  printf("%f %d %.6e %.6e %.16e\n",ti,n,g1,g2,g2-g1);
  
  return -sqrt(-1.0);
};

double trapez_mp(int n, double umin, double umax, double ti, struct IncoherentPhonon_physics_storage_struct *data,
		 double (*func)(double,double,struct IncoherentPhonon_physics_storage_struct *))
{
  int i;
  double u, du, hdu, s, f1, f2;

  if(n<=0) {
    printf("quad: invalid n = %d\n",n);
    exit(1);
  }

  du = (umax-umin)/n;
  hdu = 0.5*du;

  s = 0;
  u = umin;
  f1 = func(u,ti,data);
  for(i=1;i<=n;i++) {
    u += du;
    f2 = func(u,ti,data);
    s += hdu*(f1+f2);
    f1 = f2;
  }

  return s;
};

////////////////////////////
// Auxiliary functions   ///
////////////////////////////

double interpFunc(double u, int n, double *up, double *Fp)
{
  int i, imin, imax;
  double a;

  if(u<up[0]) {
    if(fabs(u-up[0])<1.0e-8) { return Fp[0]; }
    printf("interpFunc out of range 0: %.16e %.16e\n",u,up[0]);
    return -sqrt(-1.);
  }
  if(u>up[n-1]) {
    if(fabs(u-up[n-1])<1.0e-8) { return Fp[n-1]; }
    printf("interpFunc out of range np: %.16e %.16e\n",u,up[n-1]);
    return -sqrt(-1.);
  }

  // linear interpolation
  imin=0; imax=n-1;
  while(imax-imin>1) {
    i = (imax + imin)/2;
    if (u<up[i]) { imax = i; } else { imin = i; }
  }

  if(imax==imin) { printf("interpFunc: imax = imin %d %d\n",imin,imax); return -sqrt(-1.0); }
  if(u<up[imin] || u>up[imax]) { 
    printf("interpFunc: bad bracketing: %d %d %f %f %f\n",imin,imax,up[imin],u,up[imax]);
    return -sqrt(-1.);
  }

  // slope
  a = (Fp[imax]-Fp[imin])/(up[imax]-up[imin]);

  return Fp[imin] + a*(u-up[imin]);
};

////////////////////////////////
// functions for the DoS     ///
////////////////////////////////

double dos(double E, struct IncoherentPhonon_physics_storage_struct *data)
{
  int i, imin, imax;
  double Emax = data->Emax;
  double *e = data->e;
  double *Z = data->Z;
  int np = data->np;

  //if(E<=0 || E>=Emax) { return 0; }

  if(E<0) { E = -E; }

  if(E>=Emax) { return 0; }

  // parabolic around E=0
  if(E<=e[1]) {
    return (data->dosPar)*E*E;
  }

  // linear interpolation elsewhere
  imin=1; imax=np-1;
  while(imax-imin>1) {
    i = (imax + imin)/2;
    if (E<e[i]) { imax = i; } else { imin = i; }
  }

  return Z[imin]+(E-e[imin])*(Z[imax]-Z[imin])/(e[imax]-e[imin]);
};

void readDoS(struct IncoherentPhonon_physics_storage_struct *data)
{
  char *snp = "#np:", s[100]="";
  int i, np, nptrim, nread;
  double *e, *Z, norm;
  FILE *filep;

  filep = fopen(data->dosfn,"r");

  if(filep==NULL) {
    fprintf(data->filep,"readDos: dos file %s not found\n",data->dosfn);
    fprintf(data->filep,"stopping computation\n");
    printf("readDos: dos file %s not found\n",data->dosfn);
    printf("stopping computation\n");
    exit(1);
  }

  while(strcmp(s,snp)) {
     nread = fscanf(filep,"%s",s);
     if(nread!=1) { 
       printf("readDoS: not valid file %s\n",data->dosfn);
       fprintf(data->filep,"readDoS: not valid file %s\n",data->dosfn);
       exit(1); }
  }
  nread = fscanf(filep,"%d",&np);	

  e = (double *)malloc(np*sizeof(double));
  Z = (double *)malloc(np*sizeof(double));

  for(i=0;i<np;i++) {
     nread = fscanf(filep,"%lf %lf",e+i,Z+i);
  }

  fclose(filep);

  // Make DoS vanish at E=0
  for(i=np-1;i>=0;i--) { Z[i] -= Z[0]; }

  //trim the dos
  nptrim = 0;
  for(i=np-1;i>=0;i--) { 
    if(Z[i]>1.0e-12) {
      nptrim = i+2;
      break;
    }
  }

  data->np = nptrim;
  data->e = (double *)malloc(nptrim*sizeof(double));
  data->Z = (double *)malloc(nptrim*sizeof(double));
  for(i=0;i<nptrim&&i<np;i++) {
    (data->e)[i] = e[i];
    (data->Z)[i] = Z[i];
  }
  if(nptrim > np) {
    (data->e)[nptrim-1] = 2.*e[np-1] - e[nptrim-2];
  }
  (data->Z)[nptrim-1] = 0;

  // parameters
  data->dosPar = (data->Z)[1]/pow((data->e)[1]-(data->e)[0],2);
  data->Emax = (data->e)[nptrim-1];

  // dos normalization (very important)
  norm = (data->dosPar)*pow((data->e)[1],3)/3.; // parabolic at origin
  for(i=2;i<nptrim;i++) {
    norm += 0.5*((data->Z)[i]+(data->Z)[i-1])*((data->e)[i]-(data->e)[i-1]);
  }
  for(i=0;i<nptrim;i++) {
    (data->Z)[i] /= norm;
  }
  data->dosPar /= norm;

  fprintf(data->filep,"DoS norm: %f\n",norm);

  free(e);
  free(Z);

  filep = fopen("interpDoS.txt","w");
  for(i=0;i<10001;i++) {
     fprintf(filep,"%.16e %.16e\n",i*(data->Emax)/10000,dos(i*(data->Emax)/10000,data));
  }
  fclose(filep);
};

//////////////////////////////
// initialization functions //
//////////////////////////////

void setParams(struct IncoherentPhonon_physics_storage_struct *data, 
               double T, double density, double M, 
	       double sigmaCoh, double sigmaInc,
	       double kabsmin, double kabsmax, int nxs, 
	       char *dosfn, int ntsp, double ximin, double ximax, char *filelog)
{
  // log file
  data->filep = fopen(filelog,"w");
  fprintf(data->filep,"Initializing\n");

  // initialize parameters
  data->T = T;
  data->density = density;
  data->M = M;
  data->sigmaCoh = sigmaCoh;
  data->sigmaInc = sigmaInc;
  data->kabsmin = kabsmin;
  data->kabsmax = kabsmax;
  data->nxs = nxs;
  data->kBT = kB*T;
  data->mRat = (MNEUTRON/amu)/M;
  data->XS2mu = 100*(density/M)*(NA*barn2cmsq); //the factor 100 to convert from cm-1 to m-1

  data->ntsp = ntsp;
  data->ximin = ximin;
  data->ximax = ximax;
  data->xi1 = 0.8;
  data->xi2 = 1.2;

  data->tolSaddlePoint = 1.0e-8;
  data->tolQuadratureFs = 1.0e-6;
  data->tolQuadratureGs = 1.0e-8;

  data->np_u_mph = 100;
  data->tol_dXSdu_mph = 1.0e-6;

  strcpy(data->dosfn,dosfn);

  readDoS(data);

  data->g0 = Gt(0,data);
  data->d2g0 = d2Gt(0,data);

  fprintf(data->filep,"Parameters computed\n");
  fprintf(data->filep,"*************************\n");
  fprintf(data->filep,"Input parameters:\n");
  fprintf(data->filep,"T: %f\n",data->T);
  fprintf(data->filep,"density: %f\n",data->density);
  fprintf(data->filep,"M: %f\n",data->M);
  fprintf(data->filep,"sigmaCoh: %f\n",data->sigmaCoh);
  fprintf(data->filep,"sigmaInc: %f\n",data->sigmaInc);
  fprintf(data->filep,"kabsmin: %f\n",data->kabsmin);
  fprintf(data->filep,"kabsmax: %f\n",data->kabsmax);
  fprintf(data->filep,"nxs: %d\n",data->nxs);
  fprintf(data->filep,"kBT: %f\n",data->kBT);
  fprintf(data->filep,"mRat: %f\n",data->mRat);
  fprintf(data->filep,"XS2mu: %f\n",data->XS2mu);
  fprintf(data->filep,"Emax: %f\n",data->Emax);
  fprintf(data->filep,"dosPar: %f\n",data->dosPar);
  fprintf(data->filep,"ntsp: %d\n",data->ntsp);
  fprintf(data->filep,"ximin: %f\n",data->ximin);
  fprintf(data->filep,"ximax: %f\n",data->ximax);
  fprintf(data->filep,"G(0): %f\n",data->g0);
  fprintf(data->filep,"d2G(0): %f\n",data->d2g0);
  fprintf(data->filep,"np_u_mph: %d\n",data->np_u_mph);
  fprintf(data->filep,"tolSaddlePoint: %.6e\n",data->tolSaddlePoint);
  fprintf(data->filep,"tolQuadratureGs: %.6e\n",data->tolQuadratureGs);
  fprintf(data->filep,"tolQuadratureFs: %.6e\n",data->tolQuadratureFs);
  fprintf(data->filep,"tol_dXSdu_mph: %.6e\n",data->tol_dXSdu_mph);
  fprintf(data->filep,"*************************\n");

  fflush(data->filep);

  computeTotXS(data);
};

////////////////////////////
// finishing functions  ////
////////////////////////////

int finish(struct IncoherentPhonon_physics_storage_struct *data)
{  
  // deallocate allocated memory
  if(data->e != NULL) { free(data->e); data->e=NULL;}
  if(data->Z != NULL) { free(data->Z); data->Z=NULL;}

  if(data->kabs != NULL) { free(data->kabs); data->kabs=NULL;}

  if(data->xsTot_1ph != NULL) { free(data->xsTot_1ph); data->xsTot_1ph=NULL; }
  if(data->xsTot_2ph != NULL) { free(data->xsTot_2ph); data->xsTot_2ph=NULL; }
  if(data->xsTot_3ph != NULL) { free(data->xsTot_3ph); data->xsTot_3ph=NULL; }
  if(data->xsTot_mph != NULL) { free(data->xsTot_mph); data->xsTot_mph=NULL; }
  if(data->dXSdx_xmax_1ph != NULL) { free(data->dXSdx_xmax_1ph); data->dXSdx_xmax_1ph=NULL; }
  if(data->dXSdx_xmax_2ph != NULL) { free(data->dXSdx_xmax_2ph); data->dXSdx_xmax_2ph=NULL; }
  if(data->dXSdx_xmax_3ph != NULL) { free(data->dXSdx_xmax_3ph); data->dXSdx_xmax_3ph=NULL; }
  if(data->dXSdx_Fmax_1ph != NULL) { free(data->dXSdx_Fmax_1ph); data->dXSdx_Fmax_1ph=NULL; }
  if(data->dXSdx_Fmax_2ph != NULL) { free(data->dXSdx_Fmax_2ph); data->dXSdx_Fmax_2ph=NULL; }
  if(data->dXSdx_Fmax_3ph != NULL) { free(data->dXSdx_Fmax_3ph); data->dXSdx_Fmax_3ph=NULL; }

  if(data->u != NULL) { free(data->u); data->u=NULL; }
  if(data->dXSdu_mph != NULL) { free(data->dXSdu_mph); data->dXSdu_mph=NULL; }

  if(data->u1 != NULL) { free(data->u1); data->u1=NULL; }
  if(data->u2 != NULL) { free(data->u2); data->u2=NULL; }
  if(data->u3 != NULL) { free(data->u3); data->u3=NULL; }
  if(data->F1 != NULL) { free(data->F1); data->F1=NULL; }
  if(data->F2 != NULL) { free(data->F2); data->F2=NULL; }
  if(data->F3 != NULL) { free(data->F3); data->F3=NULL; }

  if(data->xi != NULL) { free(data->xi); data->xi=NULL; }
  if(data->tsp != NULL) { free(data->tsp); data->tsp=NULL; }
  if(data->g != NULL) { free(data->g); data->g=NULL; }
  if(data->d2g != NULL) { free(data->d2g); data->d2g=NULL; }
  if(data->H != NULL) { free(data->H); data->H=NULL; }

  if(data->u != NULL) { free(data->u); data->u=NULL; }
  if(data->dXSdu_mph != NULL) { free(data->dXSdu_mph); data->dXSdu_mph=NULL; }

  if(data->dXSdQ2_Q2max_mph != NULL) { free(data->dXSdQ2_Q2max_mph); data->dXSdQ2_Q2max_mph=NULL; }
  if(data->dXSdQ2_Fmax_mph != NULL) { free(data->dXSdQ2_Fmax_mph); data->dXSdQ2_Fmax_mph=NULL; }

  fprintf(data->filep,"run finished\n");
  
  if(data->filep!=NULL) { fclose(data->filep); data->filep=NULL; }
  
  return 1;
};

// End implementation of internal functions

%}

DECLARE
%{
// Needed for transport to the main component
struct global_process_element_struct global_process_element;
struct scattering_process_struct This_process;

#ifndef PROCESS_DETECTOR
	//struct pointer_to_global_process_list global_process_list = {0,NULL};
	#define PROCESS_DETECTOR dummy
#endif

// Declare for this component, to do calculations on the input / store in the transported data
struct IncoherentPhonon_physics_storage_struct IncoherentPhonon_storage;

%}

INITIALIZE
%{
  // Initialize done in the component
  char filelog[250];
  sprintf(filelog,"IncoherentPhonon_process_%s.log",NAME_CURRENT_COMP);
  // parameters for numerical computation
  int    ntsp = 2000;
  double ximin = -200;
  double ximax = 200;

  setParams(&IncoherentPhonon_storage,T,density,M,sigmaCoh,sigmaInc,kabsmin,kabsmax,nxs,dosfn,ntsp,ximin,ximax,filelog);

  // Need to specify if this process is isotropic
  This_process.non_isotropic_rot_index = -1; // Yes (powder)
  //This_process.non_isotropic_rot_index =  1;  // No (single crystal)

  // Packing the data into a structure that is transported to the main component
  sprintf(This_process.name,NAME_CURRENT_COMP);
  This_process.process_p_interact = interact_fraction;
  This_process.data_transfer.pointer_to_a_IncoherentPhonon_physics_storage_struct = &IncoherentPhonon_storage;

  This_process.probability_for_scattering_function = &IncoherentPhonon_physics_my;
  This_process.scattering_function = &IncoherentPhonon_physics_scattering;

  // This will be the same for all process's, and can thus be moved to an include.
  sprintf(global_process_element.name,NAME_CURRENT_COMP);
  global_process_element.component_index = INDEX_CURRENT_COMP;
  global_process_element.p_scattering_process = &This_process;
  add_element_to_process_list(&global_process_list,global_process_element);

  fprintf(IncoherentPhonon_storage.filep,"Initialization done\n");	
 %}

TRACE
%{
%}

FINALLY
%{
// deallocate allocated memory, etc.
struct IncoherentPhonon_physics_storage_struct *data = This_process.data_transfer.pointer_to_a_IncoherentPhonon_physics_storage_struct;
finish(data);
%}

END
